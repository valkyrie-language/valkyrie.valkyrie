namespace package::compiler;

using package::lexer::ValkyrieLexer;
using package::parser::ValkyrieParser;
using package::generation::JsCodeGeneration;

class Compiler {
    constructor(options: CompilerOptions) {
        self.options = options || new CompilerOptions();
        self.diagnostics = new CompilerDiagnostics();
    }
}


# Main compilation function with multiple diagnostics support, map of path, source text
# returns {success: Boolean, diagnostics: CompilerDiagnostics[], code: String }
micro compile_with_compiler(compiler: Compiler, files: Map<String, String>) -> Object {
    compiler.diagnostics.clear_diagnostics();
    # 1.遍历所有文件, 生成 ast
    let asts = {};
    let file_paths = Object.keys(files);
    let ast_index = 0;
    while ast_index < file_paths.length {
        let path = file_paths[ast_index];
        let source_text = files[path];

        # 1.1 词法分析
        let lexer = new ValkyrieLexer(source_text);
        let tokens = lexer.tokenize();

        if compiler.diagnostics.has_errors() {
            ast_index = ast_index + 1;
            continue;
        }

        # 1.2 语法分析
        let parser = new ValkyrieParser(compiler.options);
        let program = parser.parse(tokens);
        if program.`type` == "ParseError" {
            compiler.diagnostics.add_error(path + " "+ program.message, program.line, program.column);
        }
        else {
            asts[path] = program;
        }
        ast_index = ast_index + 1;
    }
    # 2. 遍历 ast, 根据 namespace 分组
    let namespace_groups = {};
    let ast_paths = Object.keys(asts);
    let path_index = 0;

    console.log("Total AST files:", ast_paths.length);

    while path_index < ast_paths.length {
        let file_path = ast_paths[path_index];
        let program = asts[file_path];
        # 查找文件中的所有 namespace 声明并收集其 body
        if program && program.statements && program.statements.length > 0 {
            let current_namespace = [];
            let current_body = [];

            let stmt_index = 0;
            while stmt_index < program.statements.length {
                let statement = program.statements[stmt_index];

                # 检查是否是 namespace 声明
                if statement && statement.`type` == "NamespaceStatement" {
                    # 如果已经有正在处理的 namespace，先保存它
                     if current_namespace.length > 0 {
                         let path_key = make_namespace_key(current_namespace);
                         let group = namespace_groups[path_key];
                         if !group {
                             group = new NamespaceGroup(current_namespace);
                             namespace_groups[path_key] = group;
                         }

                         let namespace_node = {};
                         namespace_node["type"] = "NamespaceStatement";
                         namespace_node["file"] = file_path;
                         namespace_node["path"] = current_namespace;
                         namespace_node["is_main_namespace"] = false;
                         namespace_node["body"] = current_body;

                         group.add_namespace(namespace_node);

                         # 重置当前 namespace 和 body
                         current_namespace = [];
                         current_body = [];
                     }

                    # 设置新的 namespace
                     current_namespace = [];
                     if statement.path && statement.path.name_path && statement.path.name_path.length > 0 {
                         let name_index = 0;
                         while name_index < statement.path.name_path.length {
                             let identifier = statement.path.name_path[name_index];
                             if identifier && identifier.name {
                                 current_namespace.push(identifier.name);
                             }
                             name_index = name_index + 1;
                         }
                     }

                } else {
                    # 如果不是则添加到 body
                    current_body.push(statement);
                }

                stmt_index = stmt_index + 1;
            }

            # 处理文件末尾的 namespace
             if current_namespace.length > 0 {
                 let path_key = make_namespace_key(current_namespace);
                 let group = namespace_groups[path_key];
                 if !group {
                     group = new NamespaceGroup(current_namespace);
                     namespace_groups[path_key] = group;
                 }

                 let namespace_node = {};
                 namespace_node["type"] = "NamespaceStatement";
                 namespace_node["file"] = file_path;
                 namespace_node["path"] = current_namespace;
                 namespace_node["is_main_namespace"] = false;
                 namespace_node["body"] = current_body;

                 group.add_namespace(namespace_node);
             }
        } else {
            console.log("No statements found in program");
        }

        path_index = path_index + 1;
    }

    console.log("Found namespace groups:", Object.keys(namespace_groups));

    # 第三阶段, 构建全局符号表
    let global_symbol_table = {};
    
    # 首先收集所有命名空间的符号到全局符号表
    let namespace_keys = Object.keys(namespace_groups);
    let key_index = 0;
    while key_index < namespace_keys.length {
        let namespace_key = namespace_keys[key_index];
        let group = namespace_groups[namespace_key];
        
        # 收集该组的声明到全局符号表
        group.collect_declarations();
        let decl_index = 0;
        while decl_index < group.declarations.length {
            let declaration = group.declarations[decl_index];
            let unique_name = group.generate_unique_name(declaration, group.path);
            if unique_name != "" {
                global_symbol_table[unique_name] = declaration;
            }
            decl_index = decl_index + 1;
        }
        
        key_index = key_index + 1;
    }
    
    # 然后为每个命名空间组设置全局符号表并解析
    key_index = 0;
    while key_index < namespace_keys.length {
        let namespace_key = namespace_keys[key_index];
        let group = namespace_groups[namespace_key];
        
        # 设置全局符号表
        group.global_symbol_table = global_symbol_table;
        # 为组中的所有声明生成唯一名称
        group.resolve();

        key_index = key_index + 1;
    }

    # 第四阶段, 整合成一个 ast 并使用 js codegen 生成代码
    console.log("=== 第四阶段: AST整合和代码生成 ===");

    # 整合所有namespace组的声明到一个统一的AST中
    let combined_ast = {};
    combined_ast["type"] = "Program";
    combined_ast.body = [];
    combined_ast.declarations = [];
    combined_ast.statements = []; # 为JsCodeGeneration提供兼容的statements字段

    # 收集所有声明到统一的AST中
    let group_keys = Object.keys(namespace_groups);
    let group_index = 0;
    while group_index < group_keys.length {
        let namespace_key = group_keys[group_index];
        let group = namespace_groups[namespace_key];

        # 将每个组的声明添加到统一AST中
        let decl_index = 0;
        while decl_index < group.declarations.length {
            let declaration = group.declarations[decl_index];
            combined_ast.declarations.push(declaration);
            decl_index = decl_index + 1;
        }

        # 将每个namespace的body内容添加到统一AST中
        let ns_index = 0;
        while ns_index < group.namespaces.length {
            let `namespace` = group.namespaces[ns_index];
            let stmt_index = 0;
            while stmt_index < `namespace`.body.length {
                let statement = `namespace`.body[stmt_index];
                combined_ast.body.push(statement);
                combined_ast.statements.push(statement);
                stmt_index = stmt_index + 1;
            }
            ns_index = ns_index + 1;
        }

        group_index = group_index + 1;
    }

    # 使用现有的JsCodeGeneration类生成代码
    let code_generator = new JsCodeGeneration("  ", compiler.options);
    let generated_code = code_generator.generate(combined_ast);

    console.log("=== 代码生成完成 ===");

    # 返回编译结果
    return {
        success: !compiler.diagnostics.has_errors(),
        diagnostics: compiler.diagnostics.get_all_diagnostics(),
        # namespace_groups: namespace_groups,
        # combined_ast: combined_ast,
        code: generated_code
    };
}

# 从 namespace 路径数组生成字符串 key
micro make_namespace_key(namespace_path: Array<String>) -> String {
    if namespace_path.length == 0 {
        return "";
    }
    return namespace_path.join("__");
}