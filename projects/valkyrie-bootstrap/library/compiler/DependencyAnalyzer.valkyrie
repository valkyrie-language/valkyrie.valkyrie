namespace package::compiler;

using package::parser::Node;
using package::compiler::NamespaceManager;
using package::compiler::CompilerOptions;

class DependencyAnalyzer {
    constructor() {
        self.dependencies = {};
        self.reverse_dependencies = {};
    }
}

# Topological sort (simplified version, no cycle detection)
micro topological_sort_with_analyzer(analyzer: DependencyAnalyzer, file_contents: Map<String, String>) -> Map<String, String> {
    let file_names = Object.keys(file_contents);
    let visited = {};
    let sorted = [];

    let i = 0;
    while i < file_names.length {
        visited[file_names[i]] = false;
        i = i + 1;
    }

    let j = 0;
    while j < file_names.length {
        simple_dfs_visit_with_analyzer(analyzer, file_names[j], visited, sorted);
        j = j + 1;
    }

    return {
        "sorted": sorted,
        "error": null
    };
}

# Simple depth-first search visit
micro simple_dfs_visit_with_analyzer(analyzer: DependencyAnalyzer, file_path: String, visited: Map<String, Bool>, sorted: Array<String>) {
    if visited[file_path] {
        return;
    }

    visited[file_path] = true;

    let dependencies = analyzer.dependencies[file_path];
    if dependencies != null {
        let i = 0;
        while i < dependencies.length {
            simple_dfs_visit_with_analyzer(analyzer, dependencies[i], visited, sorted);
            i = i + 1;
        }
    }

    sorted.push(file_path);
}