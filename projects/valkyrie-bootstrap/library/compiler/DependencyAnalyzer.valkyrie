namespace package::compiler;

using package::parser::Node;
using package::compiler::NamespaceManager;
using package::compiler::CompilerOptions;

class DependencyAnalyzer {
    constructor() {
        self.dependencies = {};
        self.reverse_dependencies = {};
    }

    # Topological sort (simplified version, no cycle detection)
    micro topological_sort(self, file_contents: Map<String, String>) -> Map<String, String> {
        let file_names = Object.keys(file_contents);
        let visited = {};
        let sorted = [];

        let i = 0;
        while i < file_names.length {
            visited[file_names[i]] = false;
            i = i + 1;
        }

        let j = 0;
        while j < file_names.length {
            self.simple_dfs_visit(file_names[j], visited, sorted);
            j = j + 1;
        }

        return {
            "sorted": sorted,
            "error": null
        };
    }

    # Simple depth-first search visit
    micro simple_dfs_visit(self, file_path: String, visited: Map<String, Bool>, sorted: Array<String>) {
        if visited[file_path] {
            return;
        }

        visited[file_path] = true;

        let dependencies = self.dependencies[file_path];
        if dependencies != null {
            let i = 0;
            while i < dependencies.length {
                self.simple_dfs_visit(dependencies[i], visited, sorted);
                i = i + 1;
            }
        }

        sorted.push(file_path);
    }
}
