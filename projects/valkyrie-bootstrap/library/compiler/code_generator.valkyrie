namespace package::compiler;

using package::lexer::ValkyrieLexer;
using package::parser::parse;
using package::codegen::JsCodeGeneration;
using package::parser::Node;
using package::compiler::DependencyAnalyzer;
using package::compiler::CompilerOptions;
using package::compiler::CompilerDiagnostics;
using package::compiler::NamespaceManager;
using package::compiler::NamespaceUtils;
using package::compiler::IdentifierResolver;
using package::compiler::Compiler;
using package::codegen::join_name_path;

# Generate single JS file main function
micro compile_asts(file_contents: Map<String, String>, mode: String) -> Map<String, String> {
    return compile_asts_with_options(file_contents, mode, null);
}

# Generate single JS file with options and multiple diagnostics support
micro compile_asts_with_options(file_contents: Map<String, String>, mode: String, options: CompilerOptions) -> Map<String, String> {
    if options == null {
        options = new CompilerOptions("js", false, false, "warning", mode || "repl");
    } else if options.mode == null {
        options.mode = mode || "repl";
    }
    
    let compiler = new Compiler(options);
    return compile_with_compiler(compiler, file_contents);
}

# Resolve multiple namespaces (legacy function, kept for compatibility)
micro resolve_multiple_namespaces(ast: Node) -> Node {
    let manager = new NamespaceManager();
    
    # First pass: collect all namespaces and symbols
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            let namespace_path = join_name_path(stmt.path, "::");
            if stmt.isMainNamespace {
                namespace_path = namespace_path + "!";
            }
            manager.current_namespace = namespace_path;
            
        } else if stmt.type == "UsingStatement" {
            let using_path = join_name_path(stmt.path, "::");
            let is_global = is_main_namespace(using_path);
            add_using_import(manager, using_path, is_global);
            
        } else if stmt.type == "MicroDeclaration" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "function", stmt, manager.current_file);
            
        } else if stmt.type == "ClassDeclaration" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "class", stmt, manager.current_file);
            
        } else if stmt.type == "LetStatement" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "variable", stmt, manager.current_file);
        }
        
        i = i + 1;
    }
    
    # Second pass: resolve symbol references and generate unique names
    let j = 0;
    while j < ast.statements.length {
        let stmt = ast.statements[j];
        
        if stmt.type == "MicroDeclaration" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
            
        } else if stmt.type == "ClassDeclaration" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
            
        } else if stmt.type == "LetStatement" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
        }
        
        j = j + 1;
    }
    
    return ast;
}