namespace package::compiler;

using package::parser::Node;

class NamespaceManager {
    constructor(source) {
        self.namespaces = {};
        self.usings = {};
        self.currentNamespace = "";
        self.currentFile = "";
        self.mode = "repl";
    }
}


# 检查是否为主命名空间
micro is_main_namespace(namespace_path: Array<String>) -> Bool {
    if namespace_path == null {
        return false;
    }
    return namespace_path.endsWith("!");
}

# 获取主命名空间名称
micro get_main_namespace_name(namespace_path: Array<String>) -> String {
    if is_main_namespace(namespace_path) {
        return namespace_path.substring(0, namespace_path.length - 1);
    }
    return namespace_path;
}

# 添加符号到命名空间
micro add_symbol_to_namespace(manager: NamespaceManager, namespace_path: Array<String>, symbol_name: String, symbol_type: String, symbol_data: Node, file_path: String) {
    if manager.namespaces[namespace_path] == null {
        manager.namespaces[namespace_path] = {
            "symbols": {},
            "files": []
        };
    }
    
    let namespace_data = manager.namespaces[namespace_path];
    
    # 添加符号
    namespace_data.symbols[symbol_name] = {
        "type": symbol_type,
        "data": symbol_data,
        "filePath": file_path
    };
    
    # 添加文件到命名空间（如果不存在）
    let file_exists = false;
    let i = 0;
    while i < namespace_data.files.length {
        if namespace_data.files[i] == file_path {
            file_exists = true;
            break;
        }
        i = i + 1;
    }
    
    if !file_exists {
        namespace_data.files.push(file_path);
    }
}

# 添加using导入
micro add_using_import(manager: NamespaceManager, using_path: Array<String>, is_global: bool) {
    if manager.usings[manager.currentFile] == null {
        manager.usings[manager.currentFile] = [];
    }
    
    let using_info = {
        "namespace": using_path,
        "isGlobal": is_global
    };
    
    manager.usings[manager.currentFile].push(using_info);
}

# 查找符号所属的命名空间
micro find_symbol_namespace(manager: NamespaceManager, symbol_name: String, symbol_type: String) -> Array<String> {
    let namespace_keys = Object.keys(manager.namespaces);
    let i = 0;
    while i < namespace_keys.length {
        let namespace_name = namespace_keys[i];
        let namespace_data = manager.namespaces[namespace_name];
        if namespace_data != null && namespace_data.symbols != null {
            let symbol = namespace_data.symbols[symbol_name];
            if symbol != null && symbol.type == symbol_type {
                return namespace_name;
            }
        }
        i = i + 1;
    }
    return "";
}

# 获取完全限定名称
micro get_fully_qualified_name(manager: NamespaceManager, symbol_name: String, namespace_path: Array<String>) -> String {
    if namespace_path == "" || namespace_path == null {
        return symbol_name;
    }
    
    let clean_namespace = get_main_namespace_name(namespace_path);
    return clean_namespace.replace("::", "_") + "_" + symbol_name;
}

# 验证命名空间规则
micro validate_namespace_rules(ast: Node, mode: String) -> Map<String, String> {
    let has_namespace = false;
    let has_main_namespace = false;
    
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            has_namespace = true;
            if stmt.isMainNamespace {
                has_main_namespace = true;
            }
        }
        
        i = i + 1;
    }
    
    if mode == "standard" && !has_namespace {
        return "Error: Standard mode requires at least one namespace declaration";
    }
    
    if mode == "standard" && !has_main_namespace {
        return "Error: Standard mode requires exactly one main namespace (ending with !)";
    }
    
    return "OK";
}

# 查找命名空间提供者
micro find_namespace_provider(namespace_path: Array<String>, file_contents: Map<String, String>) -> String {
    let file_names = Object.keys(file_contents);
    let i = 0;
    while i < file_names.length {
        let file_name = file_names[i];
        let content = file_contents[file_name];
        
        # 简单检查是否包含命名空间声明
        if content.indexOf("namespace " + namespace_path) >= 0 {
            return file_name;
        }
        
        i = i + 1;
    }
    return null;
}