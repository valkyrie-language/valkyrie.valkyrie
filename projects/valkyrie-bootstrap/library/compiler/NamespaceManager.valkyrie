namespace package::compiler;

using package::parser::Node;

using package::lexer::ValkyrieLexer;
using package::parser::parse;
using package::codegen::JsCodeGeneration;
using package::parser::Node;
using package::compiler::DependencyAnalyzer;
using package::compiler::CompilerOptions;
using package::codegen::join_name_path;


class NamespaceManager {
    constructor(source) {
        self.namespaces = {};
        self.usings = {};
        self.current_namespace = "";
        self.current_file = "";
        self.mode = "repl";
    }
}

# è®¾ç½®ç¼–è¯‘æ¨¡å¼
micro set_compile_mode(manager: NamespaceManager, mode: String) {
    manager.mode = mode;
}


# å¸¦é€‰é¡¹çš„ç”Ÿæˆå•ä¸€JSæ–‡ä»¶çš„ä¸»å‡½æ•°
micro compile_asts_with_options(file_contents: Map<String, String>, mode: String, options: CompilerOptions) -> String {
    let manager = new NamespaceManager();
    set_compile_mode(manager, mode || "repl");
    
    # åˆ†æä¾èµ–å…³ç³»
    let analyzer = new DependencyAnalyzer();
    
    # ç¬¬ä¸€éï¼šæ”¶é›†æ¯ä¸ªæ–‡ä»¶çš„usingä¾èµ–
    let file_names = Object.keys(file_contents);
    let i = 0;
    while i < file_names.length {
        let file_name = file_names[i];
        let content = file_contents[file_name];
        
        analyzer.dependencies[file_name] = [];
        
        let lexer_instance = new ValkyrieLexer(content);
        let tokens = lexer_instance.tokenize();
        
        if tokens.length > 0 {
            let ast = parse(tokens);
            
            if ast.type == "Program" {
                let j = 0;
                while j < ast.statements.length {
                    let stmt = ast.statements[j];
                    
                    if stmt.type == "UsingStatement" {
                        let using_path = join_path(stmt.path, "::");
                        let provider_file = find_namespace_provider(using_path, file_contents);
                        if provider_file != null && provider_file != file_name {
                            analyzer.dependencies[file_name].push(provider_file);
                        }
                    }
                    
                    j = j + 1;
                }
            }
        }
        
        i = i + 1;
    }
    
    # æ‹“æ‰‘æ’åº
    let sort_result = topological_sort(analyzer, file_contents);
    if sort_result.error != null {
        return {
            "success": false,
            "error": sort_result.error
        };
    }
    
    let sorted_files = sort_result.sorted;
    
    # åˆ†ç±»æ”¶é›†è¯­å¥
    let js_import_statements = [];
    let variable_statements = [];
    let function_statements = [];
    let class_statements = [];
    let execution_statements = [];
    
    # æŒ‰ä¾èµ–é¡ºåºå¤„ç†æ–‡ä»¶
    let k = 0;
    while k < sorted_files.length {
        let file_name = sorted_files[k];
        let content = file_contents[file_name];
        
        manager.current_file = file_name;
        
        let lexer_instance = new ValkyrieLexer(content);
        let tokens = lexer_instance.tokenize();
        
        if tokens.length == 0 {
            k = k + 1;
            continue;
        }
        
        let ast = parse(tokens);
        if ast.type != "Program" {
            return {
                "success": false,
                "error": "Failed to parse " + file_name + " at " + JSON.stringify(ast)
            };
        }
        
        let validation_result = validate_namespace_rules(ast, mode);
        if !validation_result.success {
            return validation_result;
        }
        
        let current_namespace = "";
        let l = 0;
        while l < ast.statements.length {
            let stmt = ast.statements[l];
            
            if stmt.type == "NamespaceStatement" {
                current_namespace = join_path(stmt.path, "::");
                if stmt.isMainNamespace {
                    current_namespace = current_namespace + "!";
                    
                    # åœ¨standardæ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥é‡å¤çš„ä¸»å‘½åç©ºé—´
                    if mode == "standard" {
                        console.log("ğŸ” æ£€æŸ¥ä¸»å‘½åç©ºé—´: " + current_namespace);
                        console.log("ğŸ“‹ å½“å‰ç®¡ç†å™¨ä¸­çš„å‘½åç©ºé—´: " + Object.keys(manager.namespaces).join(", "));
                        if manager.namespaces[current_namespace] != null {
                            let clean_name = current_namespace.substring(0, current_namespace.length - 1);
                            console.log("âŒ å‘ç°é‡å¤çš„ä¸»å‘½åç©ºé—´: " + clean_name);
                            return {
                                "success": false,
                                "error": "Duplicate main namespace '" + clean_name + "' found. Each main namespace must have a unique name."
                            };
                        } else {
                            console.log("âœ… ä¸»å‘½åç©ºé—´æ£€æŸ¥é€šè¿‡: " + current_namespace);
                        }
                    }
                }
                manager.current_namespace = current_namespace;
                
            } else if stmt.type == "UsingStatement" {
                let using_path = join_path(stmt.path, "::");
                let is_global = is_main_namespace(using_path);
                add_using_import(manager, using_path, is_global);
                
            } else if stmt.type == "JSImportStatement" {
                js_import_statements.push(stmt);
                
            } else if stmt.type == "LetStatement" {
                stmt.sourceNamespace = current_namespace;
                variable_statements.push(stmt);
                add_symbol_to_namespace(manager, current_namespace, stmt.name, "variable", stmt, file_name);
                
            } else if stmt.type == "MicroDeclaration" {
                stmt.sourceNamespace = current_namespace;
                function_statements.push(stmt);
                add_symbol_to_namespace(manager, current_namespace, stmt.name, "function", stmt, file_name);
                
            } else if stmt.type == "ClassDeclaration" {
                stmt.sourceNamespace = current_namespace;
                class_statements.push(stmt);
                add_symbol_to_namespace(manager, current_namespace, stmt.name, "class", stmt, file_name);
                
            } else {
                execution_statements.push(stmt);
            }
            
            l = l + 1;
        }
        
        k = k + 1;
    }
    
    # æ£€æŸ¥é‡å¤ä¸»å‘½åç©ºé—´ï¼ˆä»…åœ¨standardæ¨¡å¼ä¸‹ï¼‰
    if mode == "standard" {
        let main_namespaces = [];
        let main_namespace_names = [];
        
        # éå†æ‰€æœ‰å‘½åç©ºé—´ï¼Œæ”¶é›†ä¸»å‘½åç©ºé—´
        let namespace_keys = Object.keys(manager.namespaces);
        let ns_index = 0;
        while ns_index < namespace_keys.length {
            let ns_name = namespace_keys[ns_index];
            if ns_name.endsWith("!") {
                main_namespaces.push(ns_name);
                # æå–å¹²å‡€çš„å‘½åç©ºé—´åç§°ï¼ˆå»æ‰!ï¼‰
                let clean_name = ns_name.substring(0, ns_name.length - 1);
                main_namespace_names.push(clean_name);
            }
            ns_index = ns_index + 1;
        }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„ä¸»å‘½åç©ºé—´åç§°
        let duplicate_index = 0;
        while duplicate_index < main_namespace_names.length {
            let current_name = main_namespace_names[duplicate_index];
            let check_index = duplicate_index + 1;
            while check_index < main_namespace_names.length {
                if main_namespace_names[check_index] == current_name {
                    return {
                        "success": false,
                        "error": "Duplicate main namespace '" + current_name + "' found. Each main namespace must have a unique name."
                    };
                }
                check_index = check_index + 1;
            }
            duplicate_index = duplicate_index + 1;
        }
    }
    
    # ç”Ÿæˆå”¯ä¸€åç§°
    let m = 0;
    while m < function_statements.length {
        let func_stmt = function_statements[m];
        func_stmt.uniqueName = get_fully_qualified_name(manager, func_stmt.name, func_stmt.sourceNamespace);
        m = m + 1;
    }
    
    let n = 0;
    while n < class_statements.length {
        let class_stmt = class_statements[n];
        class_stmt.uniqueName = get_fully_qualified_name(manager, class_stmt.name, class_stmt.sourceNamespace);
        n = n + 1;
    }
    
    let o = 0;
    while o < variable_statements.length {
        let var_stmt = variable_statements[o];
        var_stmt.uniqueName = get_fully_qualified_name(manager, var_stmt.name, var_stmt.sourceNamespace);
        o = o + 1;
    }
    
    # åˆå¹¶æ‰€æœ‰è¯­å¥
    let integrated_ast = {
        "type": "Program",
        "statements": []
    };
    
    let p = 0;
    while p < js_import_statements.length {
        integrated_ast.statements.push(js_import_statements[p]);
        p = p + 1;
    }
    
    let q = 0;
    while q < variable_statements.length {
        let var_stmt = variable_statements[q];
        if var_stmt.uniqueName != null && var_stmt.uniqueName != var_stmt.name {
            # åˆ›å»ºä¸€ä¸ªå‰¯æœ¬å¹¶ä½¿ç”¨å”¯ä¸€åç§°
            let modified_stmt = Object.assign({}, var_stmt);
            modified_stmt.name = var_stmt.uniqueName;
            integrated_ast.statements.push(modified_stmt);
        } else {
            integrated_ast.statements.push(var_stmt);
        }
        q = q + 1;
    }
    
    let r = 0;
    while r < function_statements.length {
        let func_stmt = function_statements[r];
        if func_stmt.uniqueName != null && func_stmt.uniqueName != func_stmt.name {
            # åˆ›å»ºä¸€ä¸ªå‰¯æœ¬å¹¶ä½¿ç”¨å”¯ä¸€åç§°
            let modified_stmt = Object.assign({}, func_stmt);
            modified_stmt.name = func_stmt.uniqueName;
            # è§£æå‡½æ•°ä½“å†…çš„æ ‡è¯†ç¬¦
            modified_stmt.body = resolve_identifiers_in_statement(func_stmt.body, manager, function_statements, variable_statements, class_statements, options);
            integrated_ast.statements.push(modified_stmt);
        } else {
            # å³ä½¿æ²¡æœ‰é‡å‘½åï¼Œä¹Ÿè¦è§£æå‡½æ•°ä½“å†…çš„æ ‡è¯†ç¬¦
            let modified_stmt = Object.assign({}, func_stmt);
            modified_stmt.body = resolve_identifiers_in_statement(func_stmt.body, manager, function_statements, variable_statements, class_statements, options);
            integrated_ast.statements.push(modified_stmt);
        }
        r = r + 1;
    }
    
    let s = 0;
    while s < class_statements.length {
        let class_stmt = class_statements[s];
        let modified_stmt = Object.assign({}, class_stmt);
        
        if class_stmt.uniqueName != null && class_stmt.uniqueName != class_stmt.name {
            # ä½¿ç”¨å”¯ä¸€åç§°
            modified_stmt.name = class_stmt.uniqueName;
        }
        
        # è§£æç±»æˆå‘˜å†…éƒ¨çš„æ ‡è¯†ç¬¦
        if class_stmt.members != null {
            let resolved_members = [];
            let m = 0;
            while m < class_stmt.members.length {
                let member = class_stmt.members[m];
                let resolved_member = Object.assign({}, member);
                # åªå¯¹æ–¹æ³•ï¼ˆMemberStatementï¼‰å’Œæ„é€ å‡½æ•°ï¼ˆConstructorStatementï¼‰è¿›è¡Œç¬¦å·è§£æ
                if (member.type == "MemberStatement" || member.type == "ConstructorStatement") && member.body != null {
                    resolved_member.body = resolve_identifiers_in_statement(member.body, manager, function_statements, variable_statements, class_statements, options);
                }
                resolved_members.push(resolved_member);
                m = m + 1;
            }
            modified_stmt.members = resolved_members;
        }
        
        integrated_ast.statements.push(modified_stmt);
        s = s + 1;
    }
    
    let t = 0;
    while t < execution_statements.length {
        let resolved_stmt = resolve_identifiers_in_statement(execution_statements[t], manager, function_statements, variable_statements, class_statements, options);
        integrated_ast.statements.push(resolved_stmt);
        t = t + 1;
    }

    let generator = new JsCodeGeneration("    ");
    let generated = generator.generate(integrated_ast);

    return {
        "success": true,
        "code": generated,
        "error": null
    };
}

# è§£æå¤šä¸ªå‘½åç©ºé—´
micro resolve_multiple_namespaces(ast: Node) -> Node {
    let manager = new NamespaceManager();
    
    # ç¬¬ä¸€éï¼šæ”¶é›†æ‰€æœ‰å‘½åç©ºé—´å’Œç¬¦å·
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            let namespace_path = join_path(stmt.path, "::");
            if stmt.isMainNamespace {
                namespace_path = namespace_path + "!";
            }
            manager.current_namespace = namespace_path;
            
        } else if stmt.type == "UsingStatement" {
            let using_path = join_path(stmt.path, "::");
            let is_global = is_main_namespace(using_path);
            add_using_import(manager, using_path, is_global);
            
        } else if stmt.type == "MicroDeclaration" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "function", stmt, manager.current_file);
            
        } else if stmt.type == "ClassDeclaration" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "class", stmt, manager.current_file);
            
        } else if stmt.type == "LetStatement" {
            add_symbol_to_namespace(manager, manager.current_namespace, stmt.name, "variable", stmt, manager.current_file);
        }
        
        i = i + 1;
    }
    
    # ç¬¬äºŒéï¼šè§£æç¬¦å·å¼•ç”¨å¹¶ç”Ÿæˆå”¯ä¸€åç§°
    let j = 0;
    while j < ast.statements.length {
        let stmt = ast.statements[j];
        
        if stmt.type == "MicroDeclaration" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
            
        } else if stmt.type == "ClassDeclaration" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
            
        } else if stmt.type == "LetStatement" {
            stmt.uniqueName = get_fully_qualified_name(manager, stmt.name, manager.current_namespace);
        }
        
        j = j + 1;
    }
    
    return ast;
}


# æ£€æŸ¥æ˜¯å¦ä¸ºä¸»å‘½åç©ºé—´
micro is_main_namespace(namespace_path: Array<String>) -> Bool {
    if namespace_path == null {
        return false;
    }
    return namespace_path.endsWith("!");
}

# è·å–ä¸»å‘½åç©ºé—´åç§°
micro get_main_namespace_name(namespace_path: Array<String>) -> String {
    if is_main_namespace(namespace_path) {
        return namespace_path.substring(0, namespace_path.length - 1);
    }
    return namespace_path;
}

# æ·»åŠ ç¬¦å·åˆ°å‘½åç©ºé—´
micro add_symbol_to_namespace(manager: NamespaceManager, namespace_path: Array<String>, symbol_name: String, symbol_type: String, symbol_data: Node, file_path: String) {
    if manager.namespaces[namespace_path] == null {
        manager.namespaces[namespace_path] = {
            "symbols": {},
            "files": []
        };
    }
    
    let namespace_data = manager.namespaces[namespace_path];
    
    # æ·»åŠ ç¬¦å·
    namespace_data.symbols[symbol_name] = {
        "type": symbol_type,
        "data": symbol_data,
        "filePath": file_path
    };
    
    # æ·»åŠ æ–‡ä»¶åˆ°å‘½åç©ºé—´ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    let file_exists = false;
    let i = 0;
    while i < namespace_data.files.length {
        if namespace_data.files[i] == file_path {
            file_exists = true;
            break;
        }
        i = i + 1;
    }
    
    if !file_exists {
        namespace_data.files.push(file_path);
    }
}

# æ·»åŠ usingå¯¼å…¥
micro add_using_import(manager: NamespaceManager, using_path: Array<String>, is_global: bool) {
    if manager.usings[manager.current_file] == null {
        manager.usings[manager.current_file] = [];
    }
    
    let using_info = {
        "namespace": using_path,
        "isGlobal": is_global
    };
    
    manager.usings[manager.current_file].push(using_info);
}

# æŸ¥æ‰¾ç¬¦å·æ‰€å±çš„å‘½åç©ºé—´
micro find_symbol_namespace(manager: NamespaceManager, symbol_name: String, symbol_type: String) -> Array<String> {
    let namespace_keys = Object.keys(manager.namespaces);
    let i = 0;
    while i < namespace_keys.length {
        let namespace_name = namespace_keys[i];
        let namespace_data = manager.namespaces[namespace_name];
        if namespace_data != null && namespace_data.symbols != null {
            let symbol = namespace_data.symbols[symbol_name];
            if symbol != null && symbol.type == symbol_type {
                return namespace_name;
            }
        }
        i = i + 1;
    }
    return "";
}

# è·å–å®Œå…¨é™å®šåç§°
micro get_fully_qualified_name(manager: NamespaceManager, symbol_name: String, namespace_path: Array<String>) -> String {
    if namespace_path == "" || namespace_path == null {
        return symbol_name;
    }
    
    let clean_namespace = get_main_namespace_name(namespace_path);
    return clean_namespace.replace("::", "_") + "_" + symbol_name;
}

# éªŒè¯å‘½åç©ºé—´è§„åˆ™
micro validate_namespace_rules(ast: Node, mode: String) -> Map<String, String> {
    let has_namespace = false;
    let has_main_namespace = false;
    
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            has_namespace = true;
            if stmt.isMainNamespace {
                has_main_namespace = true;
            }
        }
        
        i = i + 1;
    }
    
    if mode == "standard" && !has_namespace {
        return {
            "success": false,
            "error": "Standard mode requires at least one namespace declaration"
        };
    }
    
    if mode == "standard" && !has_main_namespace {
        return {
            "success": false,
            "error": "Standard mode requires exactly one main namespace (ending with !)"
        };
    }
    
    return {
        "success": true,
        "error": null
    };
}

# æŸ¥æ‰¾å‘½åç©ºé—´æä¾›è€…
micro find_namespace_provider(namespace_path: Array<String>, file_contents: Map<String, String>) -> String {
    let file_names = Object.keys(file_contents);
    let i = 0;
    while i < file_names.length {
        let file_name = file_names[i];
        let content = file_contents[file_name];
        
        # ç®€å•æ£€æŸ¥æ˜¯å¦åŒ…å«å‘½åç©ºé—´å£°æ˜
        if content.indexOf("namespace " + namespace_path) >= 0 {
            return file_name;
        }
        
        i = i + 1;
    }
    return null;
}


# è§£æç¬¦å·
micro resolve_symbol(manager: NamespaceManager, symbol_name: String, current_namespace: Array<String>, current_file: String) -> Map<String, String> {
    # é¦–å…ˆåœ¨å½“å‰å‘½åç©ºé—´ä¸­æŸ¥æ‰¾
    let current_namespace_data = manager.namespaces[current_namespace];
    if current_namespace_data != null && current_namespace_data.symbols != null {
        let symbol = current_namespace_data.symbols[symbol_name];
        if symbol != null {
            return {
                "found": true,
                "symbol": symbol,
                "namespace": current_namespace
            };
        }
    }

    # ç„¶ååœ¨usingå¯¼å…¥ä¸­æŸ¥æ‰¾
    let file_usings = manager.usings[current_file];
    if file_usings != null {
        let i = 0;
        while i < file_usings.length {
            let using_info = file_usings[i];
            let using_namespace = using_info["namespace"];

            let using_namespace_data = manager.namespaces[using_namespace];
            if using_namespace_data != null && using_namespace_data.symbols != null {
                let symbol = using_namespace_data.symbols[symbol_name];
                if symbol != null {
                    return {
                        "found": true,
                        "symbol": symbol,
                        "namespace": using_namespace
                    };
                }
            }

            i = i + 1;
        }
    }

    # æœ€ååœ¨å…¨å±€å‘½åç©ºé—´ä¸­æŸ¥æ‰¾
    let global_namespace_data = manager.namespaces[""];
    if global_namespace_data != null && global_namespace_data.symbols != null {
        let symbol = global_namespace_data.symbols[symbol_name];
        if symbol != null {
            return {
                "found": true,
                "symbol": symbol,
                "namespace": ""
            };
        }
    }

    return {
        "found": false,
        "symbol": null,
        "namespace": null
    };
}


# å¸¦é€‰é¡¹çš„é€’å½’è§£æè¡¨è¾¾å¼ä¸­çš„æ ‡è¯†ç¬¦
micro resolve_identifiers_in_expression(expr: Node, manager: NamespaceManager, function_statements: Array<Node>, variable_statements: Array<Node>, class_statements: Array<Node>, options: CompilerOptions) -> Node {
    if expr == null {
        return expr;
    }

    if expr.type == "Identifier" {
        # æŸ¥æ‰¾æ˜¯å¦æ˜¯å‡½æ•°è°ƒç”¨
        let i = 0;
        while i < function_statements.length {
            let func_stmt = function_statements[i];
            if func_stmt.name == expr.name && func_stmt.uniqueName != null {
                let resolved_expr = Object.assign({}, expr);
                resolved_expr.name = func_stmt.uniqueName;
                return resolved_expr;
            }
            i = i + 1;
        }

        # æŸ¥æ‰¾æ˜¯å¦æ˜¯å˜é‡
        let j = 0;
        while j < variable_statements.length {
            let var_stmt = variable_statements[j];
            if var_stmt.name == expr.name && var_stmt.uniqueName != null {
                let resolved_expr = Object.assign({}, expr);
                resolved_expr.name = var_stmt.uniqueName;
                return resolved_expr;
            }
            j = j + 1;
        }

        return expr;
    }

    if expr.type == "MicroCall" {
        let resolved_expr = Object.assign({}, expr);

        # ç‰¹æ®Šå¤„ç†å‡½æ•°åçš„ namespace è§£æ
        if expr.callee.type == "Identifier" {
            let function_name = expr.callee.name;
            let found_function = false;
            let i = 0;
            while i < function_statements.length {
                let func_stmt = function_statements[i];
                if func_stmt.name == function_name && func_stmt.uniqueName != null {
                    let resolved_callee = Object.assign({}, expr.callee);
                    resolved_callee.name = func_stmt.uniqueName;
                    resolved_expr.callee = resolved_callee;
                    found_function = true;
                    break;
                }
                i = i + 1;
            }

            # æ£€æŸ¥implicit_member_call
            if !found_function && options != null && options.implicit_member_call == "warning" {
                # æ£€æŸ¥æ˜¯å¦å¯èƒ½æ˜¯é™æ€æ–¹æ³•è°ƒç”¨æˆ–å®ä¾‹æ–¹æ³•è°ƒç”¨
                let k = 0;
                while k < class_statements.length {
                    let class_stmt = class_statements[k];
                    if class_stmt.members != null {
                        let m = 0;
                        while m < class_stmt.members.length {
                            let member = class_stmt.members[m];
                            if member.type == "MemberStatement" && member.name == function_name {
                                # å‘å‡ºè­¦å‘Šï¼šå»ºè®®ä½¿ç”¨æ˜¾å¼çš„Self::æˆ–self.è¯­æ³•
                                let warning = create_warning(
                                    "Implicit member call detected for '" + function_name + "'. Consider using 'Self::" + function_name + "()' for static methods or 'self." + function_name + "()' for instance methods.",
                                    expr.line || 0,
                                    expr.column || 0
                                );
                                report_warning(warning);
                                break;
                            }
                            m = m + 1;
                        }
                    }
                    k = k + 1;
                }
            }

            if !found_function {
                resolved_expr.callee = resolve_identifiers_in_expression(expr.callee, manager, function_statements, variable_statements, class_statements, options);
            }
        } else {
            resolved_expr.callee = resolve_identifiers_in_expression(expr.callee, manager, function_statements, variable_statements, class_statements, options);
        }

        let resolved_args = [];
        let k = 0;
        while k < expr.arguments.length {
            resolved_args.push(resolve_identifiers_in_expression(expr.arguments[k], manager, function_statements, variable_statements, class_statements, options));
            k = k + 1;
        }
        resolved_expr.arguments = resolved_args;
        return resolved_expr;
    }

    if expr.type == "BinaryOp" {
        let resolved_expr = Object.assign({}, expr);
        resolved_expr.left = resolve_identifiers_in_expression(expr.left, manager, function_statements, variable_statements, class_statements, options);
        resolved_expr.right = resolve_identifiers_in_expression(expr.right, manager, function_statements, variable_statements, class_statements, options);
        return resolved_expr;
    }

    if expr.type == "Assignment" {
        let resolved_expr = Object.assign({}, expr);
        resolved_expr.left = resolve_identifiers_in_expression(expr.left, manager, function_statements, variable_statements, class_statements, options);
        resolved_expr.right = resolve_identifiers_in_expression(expr.right, manager, function_statements, variable_statements, class_statements, options);
        return resolved_expr;
    }

    if expr.type == "PropertyAccess" {
        let resolved_expr = Object.assign({}, expr);
        resolved_expr.object = resolve_identifiers_in_expression(expr.object, manager, function_statements, variable_statements, class_statements, options);
        return resolved_expr;
    }

    if expr.type == "NewExpression" {
        let resolved_expr = Object.assign({}, expr);

        # è§£æ classNameï¼ŒæŸ¥æ‰¾æ˜¯å¦éœ€è¦æ·»åŠ  namespace å‰ç¼€
        let m = 0;
        while m < class_statements.length {
            let class_stmt = class_statements[m];
            if class_stmt.name == expr.className && class_stmt.uniqueName != null {
                resolved_expr.className = class_stmt.uniqueName;
                break;
            }
            m = m + 1;
        }

        # è§£æå‚æ•°
        let resolved_args = [];
        if expr.arguments != null {
            let n = 0;
            while n < expr.arguments.length {
                resolved_args.push(resolve_identifiers_in_expression(expr.arguments[n], manager, function_statements, variable_statements, class_statements, options));
                n = n + 1;
            }
        }
        resolved_expr.arguments = resolved_args;
        return resolved_expr;
    }

    return expr;
}

# å¸¦é€‰é¡¹çš„é€’å½’è§£æè¯­å¥ä¸­çš„æ ‡è¯†ç¬¦
micro resolve_identifiers_in_statement(stmt: Node, manager: NamespaceManager, function_statements: Array<Node>, variable_statements: Array<Node>, class_statements: Array<Node>, options: CompilerOptions) -> Node {
    if stmt == null {
        return stmt;
    }

    if stmt.type == "LetStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        resolved_stmt.value = resolve_identifiers_in_expression(stmt.value, manager, function_statements, variable_statements, class_statements, options);
        return resolved_stmt;
    }

    if stmt.type == "ExpressionStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        resolved_stmt.expression = resolve_identifiers_in_expression(stmt.expression, manager, function_statements, variable_statements, class_statements, options);
        return resolved_stmt;
    }

    if stmt.type == "ReturnStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        if stmt.value != null {
            resolved_stmt.value = resolve_identifiers_in_expression(stmt.value, manager, function_statements, variable_statements, class_statements, options);
        }
        return resolved_stmt;
    }

    if stmt.type == "IfStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        resolved_stmt.condition = resolve_identifiers_in_expression(stmt.condition, manager, function_statements, variable_statements, class_statements, options);
        resolved_stmt.thenBranch = resolve_identifiers_in_statement(stmt.thenBranch, manager, function_statements, variable_statements, class_statements, options);
        if stmt.elseBranch != null {
            resolved_stmt.elseBranch = resolve_identifiers_in_statement(stmt.elseBranch, manager, function_statements, variable_statements, class_statements, options);
        }
        return resolved_stmt;
    }

    if stmt.type == "WhileStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        resolved_stmt.condition = resolve_identifiers_in_expression(stmt.condition, manager, function_statements, variable_statements, class_statements, options);
        resolved_stmt.body = resolve_identifiers_in_statement(stmt.body, manager, function_statements, variable_statements, class_statements, options);
        return resolved_stmt;
    }

    if stmt.type == "UntilStatement" {
        let resolved_stmt = Object.assign({}, stmt);
        resolved_stmt.condition = resolve_identifiers_in_expression(stmt.condition, manager, function_statements, variable_statements, class_statements, options);
        resolved_stmt.body = resolve_identifiers_in_statement(stmt.body, manager, function_statements, variable_statements, class_statements, options);
        return resolved_stmt;
    }

    if stmt.type == "Block" {
        let resolved_stmt = Object.assign({}, stmt);
        let resolved_statements = [];
        let i = 0;
        while i < stmt.statements.length {
            resolved_statements.push(resolve_identifiers_in_statement(stmt.statements[i], manager, function_statements, variable_statements, class_statements, options));
            i = i + 1;
        }
        resolved_stmt.statements = resolved_statements;
        return resolved_stmt;
    }

    return stmt;
}
