namespace package::parser;

# 类型操作符优先级表
micro getTypeOperatorPrecedence(tokenType: String) -> i32 {
    if tokenType == "ARROW" {
        return 1;  # -> 函数类型，右结合
    }
    if tokenType == "PIPE" {
        return 2;  # | 联合类型
    }
    if tokenType == "AMPERSAND" {
        return 3;  # & 交集类型
    }
    if tokenType == "PLUS" {
        return 4;  # + 协变
    }
    if tokenType == "MINUS" {
        return 4;  # - 逆变
    }
    return -1;
}

micro isTypeRightAssociative(tokenType: String) -> Bool {
    return tokenType == "ARROW";  # -> 是右结合的
}

# 类型表达式 Pratt 解析器主函数
micro parseTypeExpressionWithPrecedence(parser: Object, minPrecedence: i32) -> Object {
    let left = parseUnaryTypeExpression(parser);

    if left && left.type == "ParseError" {
        return left;
    }

    while true {
        let precedence = getTypeOperatorPrecedence(parser.current_token.type);
        if precedence < minPrecedence {
            break;
        }

        let op = parser.current_token.value;
        let tokenType = parser.current_token.type;
        parser.advance();

        let nextMinPrecedence = precedence;
        if isTypeRightAssociative(tokenType) {
            # 右结合，不增加优先级
        }
        else {
            nextMinPrecedence = precedence + 1;
        }

        let right = parseTypeExpressionWithPrecedence(parser, nextMinPrecedence);
        if right && right.type == "ParseError" {
            return right;
        }

        if tokenType == "ARROW" {
            let node = new Node("FunctionType");
            node.parameterType = left;
            node.returnType = right;
            left = node;
        } else if tokenType == "PIPE" {
            let node = new Node("UnionType");
            node.left = left;
            node.right = right;
            left = node;
        } else if tokenType == "AMPERSAND" {
            let node = new Node("IntersectionType");
            node.left = left;
            node.right = right;
            left = node;
        } else {
            # 其他二元类型操作符
            let node = new Node("BinaryTypeOp");
            node.left = left;
            node.operator = op;
            node.right = right;
            left = node;
        }
    }

    return left;
}

micro parseTypeExpression(parser: Object) -> Object {
    return parseTypeExpressionWithPrecedence(parser, 0);
}

# 解析一元类型表达式（前缀操作符）
micro parseUnaryTypeExpression(parser: Object) -> Object {
    # 前缀操作符：+ 协变，- 逆变
    if parser.current_token.type == "PLUS" || parser.current_token.type == "MINUS" {
        let op = parser.current_token.value;
        parser.advance();
        let operand = parseUnaryTypeExpression(parser);
        if operand && operand.type == "ParseError" {
            return operand;
        }
        let node = new Node("VarianceType");
        node.variance = op;  # "+" 或 "-"
        node.operand = operand;
        return node;
    }

    return parsePostfixTypeExpression(parser);
}

# 解析后缀类型表达式
micro parsePostfixTypeExpression(parser: Object) -> Object {
    let expr = parseAtomicTypeExpression(parser);

    if expr && expr.type == "ParseError" {
        return expr;
    }

    while true {
        # 后缀操作符：? 可空，! 必不空
        if parser.current_token.type == "QUESTION" {
            parser.advance();
            let node = new Node("NullableType");
            node.baseType = expr;
            expr = node;
        } else if parser.current_token.type == "BANG" {
            parser.advance();
            let node = new Node("NonNullType");
            node.baseType = expr;
            expr = node;
        } else if parser.current_token.type == "LT" {
            # 泛型类型参数 Type<T, U>
            parser.advance();
            let typeArgs = [];

            if parser.current_token.type != "GT" {
                let arg = parseTypeExpression(parser);
                if arg && arg.type == "ParseError" {
                    return arg;
                }
                typeArgs.push(arg);

                while parser.current_token.type == "COMMA" {
                    parser.advance();
                    arg = parseTypeExpression(parser);
                    if arg && arg.type == "ParseError" {
                        return arg;
                    }
                    typeArgs.push(arg);
                }
            }

            let gt = parser.expect("GT");
            if gt && gt.type == "ParseError" {
                return gt;
            }

            let node = new Node("GenericType");
            node.baseType = expr;
            node.typeArguments = typeArgs;
            expr = node;
        } else if parser.current_token.type == "LBRACKET" {
            # 数组类型 Type[]
            parser.advance();
            let rbracket = parser.expect("RBRACKET");
            if rbracket && rbracket.type == "ParseError" {
                return rbracket;
            }
            let node = new Node("ArrayType");
            node.elementType = expr;
            expr = node;
        } else {
            break;
        }
    }

    return expr;
}

# 解析原子类型表达式
micro parseAtomicTypeExpression(parser: Object) -> Object {
    # 基本类型标识符
    if parser.current_token.type == "IDENTIFIER" {
        let name = parser.current_token.value;
        parser.advance();
        let node = new Node("TypeIdentifier");
        node.name = name;
        return node;
    }

    # 括号类型表达式
    if parser.current_token.type == "LPAREN" {
        parser.advance();
        let expr = parseTypeExpression(parser);
        if expr && expr.type == "ParseError" {
            return expr;
        }
        let rparen = parser.expect("RPAREN");
        if rparen && rparen.type == "ParseError" {
            return rparen;
        }
        return expr;
    }

    # 元组类型 (T, U, V)
    if parser.current_token.type == "LPAREN" {
        parser.advance();
        let elements = [];

        if parser.current_token.type != "RPAREN" {
            let element = parseTypeExpression(parser);
            if element && element.type == "ParseError" {
                return element;
            }
            elements.push(element);

            while parser.current_token.type == "COMMA" {
                parser.advance();
                element = parseTypeExpression(parser);
                if element && element.type == "ParseError" {
                    return element;
                }
                elements.push(element);
            }
        }

        let rparen = parser.expect("RPAREN");
        if rparen && rparen.type == "ParseError" {
            return rparen;
        }

        # 如果只有一个元素，返回括号表达式；否则返回元组类型
        if elements.length == 1 {
            return elements[0];
        } else {
            let node = new Node("TupleType");
            node.elements = elements;
            return node;
        }
    }

    # 对象类型 { key: Type, ... }
    if parser.current_token.type == "LBRACE" {
        parser.advance();
        let properties = [];

        if parser.current_token.type != "RBRACE" {
            while parser.current_token.type == "IDENTIFIER" || parser.current_token.type == "STRING" {
                let key = parser.current_token.value;
                parser.advance();
                let colon = parser.expect("COLON");
                if colon && colon.type == "ParseError" {
                    return colon;
                }
                let valueType = parseTypeExpression(parser);
                if valueType && valueType.type == "ParseError" {
                    return valueType;
                }

                let propertyNode = new Node("TypeProperty");
                propertyNode.key = key;
                propertyNode.valueType = valueType;
                properties.push(propertyNode);

                if parser.current_token.type == "COMMA" {
                    parser.advance();
                } else {
                    break;
                }
            }
        }

        let rbrace = parser.expect("RBRACE");
        if rbrace && rbrace.type == "ParseError" {
            return rbrace;
        }

        let node = new Node("ObjectType");
        node.properties = properties;
        return node;
    }

    # 字面量类型
    if parser.current_token.type == "STRING" {
        let value = parser.current_token.value;
        parser.advance();
        let node = new Node("LiteralType");
        node.value = value;
        node.literalType = "string";
        return node;
    }

    if parser.current_token.type == "NUMBER" {
        let value = parser.current_token.value;
        parser.advance();
        let node = new Node("LiteralType");
        node.value = value;
        node.literalType = "number";
        return node;
    }

    if parser.current_token.type == "BOOLEAN" {
        let value = parser.current_token.value;
        parser.advance();
        let node = new Node("LiteralType");
        node.value = value;
        node.literalType = "boolean";
        return node;
    }

    # 如果没有匹配的类型表达式，返回错误
    let error = {};
    error.type = "ParseError";
    error.message = "Expected type expression but got " + parser.current_token.type;
    error.line = parser.current_token.line;
    error.column = parser.current_token.column;
    return error;
}

# 解析类型化参数列表 (使用 term_expression 中的 parseTypedParameter)
micro parseTypedParameters(parser: Object) -> Array {
    let params = [];

    if parser.current_token.type != "RPAREN" {
        let param = parseTypedParameter(parser);
        if param && param.type == "ParseError" {
            return param;
        }
        params.push(param);

        while parser.current_token.type == "COMMA" {
            parser.advance();
            param = parseTypedParameter(parser);
            if param && param.type == "ParseError" {
                return param;
            }
            params.push(param);
        }
    }

    return params;
}

# 在文件末尾添加三个具体的类型提示解析函数
# 解析类型提示 (: Typing)
micro parseTypeHint(parser: Object) -> Object {
    if (parser.currentToken.type == "Colon") {
        parser.advance();
        return parser.parseTypeExpression();
    }
    return null;
}

# 解析返回类型 (-> Typing)
micro parseReturnType(parser: Object) -> Object {
    if (parser.currentToken.type == "Arrow") {
        parser.advance();
        return self.parseTypeExpression();
    }
    return null;
}

# 解析效果类型 (/ Typing)
micro parseEffectType(parser: Object) -> Object {
    if (parser.currentToken.type == "Slash") {
        parser.advance();
        return parser.parseTypeExpression();
    }
    return null;
}