namespace package::parser;

using package::parser::Node;
using package::parser::ValkyrieParser;
using package::parser::parseTypeExpression;
using package::parser::parsePatternExpression;

# Pratt 解析器优先级表
micro getOperatorPrecedence(tokenType: String) -> i32 {
    if tokenType == "ASSIGN" {
        return 1;
    }
    if tokenType == "OR" {
        return 2;
    }
    if tokenType == "AND" {
        return 3;
    }
    if tokenType == "EQ" {
        return 4;
    }
    if tokenType == "NE" {
        return 4;
    }
    if tokenType == "GT" {
        return 5;
    }
    if tokenType == "LT" {
        return 5;
    }
    if tokenType == "GTE" {
        return 5;
    }
    if tokenType == "LTE" {
        return 5;
    }
    if tokenType == "IS" {
        return 5;
    }
    if tokenType == "AS" {
        return 5;
    }
    if tokenType == "PIPE" {
        return 6;
    }
    if tokenType == "AMPERSAND" {
        return 6;
    }
    if tokenType == "PLUS" {
        return 7;
    }
    if tokenType == "MINUS" {
        return 7;
    }
    if tokenType == "MULTIPLY" {
        return 8;
    }
    if tokenType == "DIVIDE" {
        return 8;
    }
    if tokenType == "MODULO" {
        return 8;
    }
    return -1;
}

micro isRightAssociative(tokenType: String) -> Bool {
    return tokenType == "ASSIGN";
}

# Pratt 解析器主函数
micro parseExpressionWithPrecedence(parser: ValkyrieParser, minPrecedence: i32, inline: bool) -> Node {
    let left = parseUnaryExpression(parser, inline);

    if left && left.type == "ParseError" {
        return left;
    }

    while true {
        let precedence = getOperatorPrecedence(parser.current_token.type);
        if precedence < minPrecedence {
            break;
        }

        let op = parser.current_token.value;
        let tokenType = parser.current_token.type;
        parser.advance();

        let nextMinPrecedence = precedence;
        if isRightAssociative(tokenType) {

        }
        else {
            nextMinPrecedence = precedence + 1;
        }

        # 对于 is 和 as 操作符，需要检查是否有 ? 后缀，并且右操作数是 pattern_expression 或 type_expression
        let right = {};
        if tokenType == "IS" {
            # 检查是否有 ? 后缀
            let isOptional = false;
            if parser.current_token.type == "QUESTION" {
                isOptional = true;
                parser.advance();
            }
            right = parsePatternExpression(parser);
            
            if isOptional {
                let node = parser.mark_node("OptionalTypeCheck");
                node.expression = left;
                node.pattern = right;
                left = node;
            } else {
                let node = parser.mark_node("TypeCheck");
                node.expression = left;
                node.pattern = right;
                left = node;
            }
        } else if tokenType == "AS" {
            # 检查是否有 ? 后缀
            let isOptional = false;
            if parser.current_token.type == "QUESTION" {
                isOptional = true;
                parser.advance();
            }
            right = parseTypeExpression(parser);
            
            if isOptional {
                let node = parser.mark_node("OptionalTypeCast");
                node.expression = left;
                node.targetType = right;
                left = node;
            } else {
                let node = parser.mark_node("TypeCast");
                node.expression = left;
                node.targetType = right;
                left = node;
            }
        } else {
            right = parseExpressionWithPrecedence(parser, nextMinPrecedence, inline);
            
            if right && right.type == "ParseError" {
                return right;
            }

            if tokenType == "ASSIGN" {
                let node = parser.mark_node("Assignment");
                node.left = left;
                node.right = right;
                left = node;
            } else {
                let node = parser.mark_node("BinaryOp");
                node.left = left;
                node.operator = op;
                node.right = right;
                left = node;
            }
        }
    }

    return left;
}

micro parseExpression(parser: ValkyrieParser) -> Node {
    return parseExpressionWithPrecedence(parser, 0, false);
}

# 新增带 inline 参数的 parseExpression 重载
micro parseInlineExpression(parser: ValkyrieParser) -> Node {
    return parseExpressionWithPrecedence(parser, 0, true);
}

micro parseUnaryExpression(parser: ValkyrieParser, inline: bool) -> Node {
    if parser.current_token.type == "BANG" || parser.current_token.type == "MINUS" {
        let op = parser.current_token.value;
        parser.advance();
        let operand = parseUnaryExpression(parser, inline);
        if operand && operand.type == "ParseError" {
            return operand;
        }
        let node = parser.mark_node("UnaryOp");
        node.operator = op;
        node.operand = operand;
        return node;
    }

    if parser.current_token.type == "NEW" {
        return parseNewExpression(parser, inline);
    }

    return parsePostfixExpression(parser, inline);
}

micro parseNewExpression(parser: ValkyrieParser, inline: bool) -> Node {
    parser.advance(); # skip 'new'

    # 解析类名
    let className = parser.expect("SYMBOL_XID");
    if className.type == "ParseError" { return className; }

    # 解析构造函数参数
    let lparen = parser.expect("LPAREN");
    if lparen.type == "ParseError" { return lparen; }

    let args = [];
    if parser.current_token.type != "RPAREN" {
        let arg = parseExpressionWithPrecedence(parser, 0, inline);
        if arg.type == "ParseError" { return arg; }
        args.push(arg);

        while parser.current_token.type == "COMMA" {
            parser.advance(); # skip comma
            arg = parseExpressionWithPrecedence(parser, 0, inline);
            if arg.type == "ParseError" { return arg; }
            args.push(arg);
        }
    }

    let rparen = parser.expect("RPAREN");
    if rparen.type == "ParseError" { return rparen; }

    let node = parser.mark_node("NewExpression");
    node.className = className.value;
    node.arguments = args;
    return node;
}

micro parsePostfixExpression(parser: ValkyrieParser, inline: bool) -> Node {
    let expr = parseAtomicExpression(parser, inline);

    if expr && expr.type == "ParseError" {
        return expr;
    }

    while true {
        if parser.current_token.type == "LPAREN" {
            # 检查是否是尾随闭包调用
            let nextIndex = parser.position + 1;
            let hasTrailingClosure = false;
            
            # 先解析普通参数
            parser.advance();
            let args = [];

            if parser.current_token.type != "RPAREN" {
                let arg = parseExpressionWithPrecedence(parser, 0, inline);
                if arg && arg.type == "ParseError" {
                    return arg;
                }
                args.push(arg);

                while parser.current_token.type == "COMMA" {
                    parser.advance();
                    arg = parseExpressionWithPrecedence(parser, 0, inline);
                    if arg && arg.type == "ParseError" {
                        return arg;
                    }
                    args.push(arg);
                }
            }

            let rparen = parser.expect("RPAREN");
            if rparen && rparen.type == "ParseError" {
                return rparen;
            }

            # 检查是否有尾随闭包 f(args) { closure_body }
            let closure = null;
            if parser.current_token.type == "LBRACE" && !inline {
                closure = parse_function_block(parser);
                if closure && closure.type == "ParseError" {
                    return closure;
                }
                hasTrailingClosure = true;
            }

            let callNode = parser.mark_node("MicroCall");
            callNode.callee = expr;
            callNode.arguments = args;
            if hasTrailingClosure {
                callNode.closure = closure;
            }
            expr = callNode;
        } else if parser.current_token.type == "DOT" {
            parser.advance();
            if parser.current_token.type == "AWAIT" {
                parser.advance();
                let awaitNode = parser.mark_node("AwaitExpression");
                awaitNode.argument = expr;
                expr = awaitNode;
            } else {
                let property = parser.expect("SYMBOL_XID");
                if property && property.type == "ParseError" {
                    return property;
                }
                let accessNode = parser.mark_node("PropertyAccess");
                accessNode.object = expr;
                accessNode.property = property.value;
                expr = accessNode;
            }
        } else if parser.current_token.type == "DOUBLE_COLON" {
            parser.advance();
            let methodName = parser.expect("SYMBOL_XID");
            if methodName && methodName.type == "ParseError" {
                return methodName;
            }
            
            # 检查是否还有更多的双冒号（支持a::b::c语法）
            let namespacePath = [expr];
            namespacePath.push(methodName.value);
            
            while parser.current_token.type == "DOUBLE_COLON" {
                parser.advance();
                let nextName = parser.expect("SYMBOL_XID");
                if nextName && nextName.type == "ParseError" {
                    return nextName;
                }
                namespacePath.push(nextName.value);
            }
            
            # 检查是否是方法调用（有括号）
            if parser.current_token.type == "LPAREN" {
                parser.advance();
                let args = [];
                
                if parser.current_token.type != "RPAREN" {
                    let arg = parseExpressionWithPrecedence(parser, 0, inline);
                    if arg && arg.type == "ParseError" {
                        return arg;
                    }
                    args.push(arg);
                    
                    while parser.current_token.type == "COMMA" {
                        parser.advance();
                        arg = parseExpressionWithPrecedence(parser, 0, inline);
                        if arg && arg.type == "ParseError" {
                            return arg;
                        }
                        args.push(arg);
                    }
                }
                
                let rparen = parser.expect("RPAREN");
                if rparen && rparen.type == "ParseError" {
                    return rparen;
                }
                
                let staticCallNode = parser.mark_node("StaticMethodCall");
                staticCallNode.namespacePath = namespacePath;
                staticCallNode.methodName = namespacePath[namespacePath.length - 1];
                staticCallNode.className = namespacePath[namespacePath.length - 2];
                staticCallNode.arguments = args;
                expr = staticCallNode;
            } else {
                # 静态属性访问
                let staticAccessNode = parser.mark_node("StaticPropertyAccess");
                staticAccessNode.namespacePath = namespacePath;
                staticAccessNode.property = namespacePath[namespacePath.length - 1];
                staticAccessNode.className = namespacePath[namespacePath.length - 2];
                expr = staticAccessNode;
            }
        } else if parser.current_token.type == "LBRACKET" {
            parser.advance();
            let index = parseExpressionWithPrecedence(parser, 0, inline);
            if index && index.type == "ParseError" {
                return index;
            }
            let rbracket = parser.expect("RBRACKET");
            if rbracket && rbracket.type == "ParseError" {
                return rbracket;
            }
            let accessNode = parser.mark_node("ArrayAccess");
            accessNode.object = expr;
            accessNode.index = index;
            expr = accessNode;
        } else {
            break;
        }
    }

    return expr;
}

micro parseAtomicExpression(parser: ValkyrieParser, inline: bool) -> Node {
    if parser.current_token.type == "NUMBER" {
        let value = parser.current_token.value;
        parser.advance();
        let node = parser.mark_node("Number");
        node.value = value;
        return node;
    }

    if parser.current_token.type == "STRING" {
        let value = parser.current_token.value;
        parser.advance();
        let node = parser.mark_node("String");
        node.value = value;
        return node;
    }

    if parser.current_token.type == "BOOLEAN" {
        let value = parser.current_token.value;
        parser.advance();
        let node = parser.mark_node("Boolean");
        node.value = value;
        return node;
    }

    if parser.current_token.type == "SYMBOL_XID" {
        let name = parser.current_token.value;
        parser.advance();
        
        # 检查是否是尾随闭包调用 f { closure_body }
        if parser.current_token.type == "LBRACE" && !inline {
            let closure = parse_function_block(parser);
            if closure && closure.type == "ParseError" {
                return closure;
            }
            
            let callNode = parser.mark_node("MicroCall");
            let identifierNode = parser.mark_node("Identifier");
            identifierNode.name = name;
            callNode.callee = identifierNode;
            callNode.arguments = [];
            callNode.closure = closure;
            return callNode;
        }
        
        let node = parser.mark_node("Identifier");
        node.name = name;
        return node;
    }

    # 匿名函数语法 micro(params) { function_block }
    if parser.current_token.type == "MICRO" {
        parser.advance(); # skip 'micro'
        
        let lparen = parser.expect("LPAREN");
        if lparen.type == "ParseError" { return lparen; }
        
        let params = parseTermParameters(parser);
        if params && params.type == "ParseError" {
            return params;
        }
        
        let rparen = parser.expect("RPAREN");
        if rparen.type == "ParseError" { return rparen; }
        
        let body = parse_function_block(parser);
        if body && body.type == "ParseError" {
            return body;
        }
        
        let node = parser.mark_node("AnonymousFunction");
        node.parameters = params;
        node.body = body;
        return node;
    }

    if parser.current_token.type == "SELF" {
        # 检查下一个token是否是双冒号，如果是则作为类名处理
        let nextIndex = parser.position + 1;
        if nextIndex < parser.tokens.length && parser.tokens[nextIndex].type == "DOUBLE_COLON" {
            let name = "Self";  # 使用标准化的Self名称
            parser.advance();
            let node = parser.mark_node("Identifier");
            node.name = name;
            return node;
        } else {
            # 否则作为this表达式处理
            parser.advance();
            let node = parser.mark_node("ThisExpression");
            return node;
        }
    }

    if parser.current_token.type == "NEW" {
        parser.advance();
        let className = parser.expect("SYMBOL_XID");
        if className && className.type == "ParseError" {
            return className;
        }

        let lparen = parser.expect("LPAREN");
        if lparen && lparen.type == "ParseError" {
            return lparen;
        }

        let args = [];
        if parser.current_token.type != "RPAREN" {
            let arg = parseExpressionWithPrecedence(parser, 0, inline);
            if arg && arg.type == "ParseError" {
                return arg;
            }
            args.push(arg);

            while parser.current_token.type == "COMMA" {
                parser.advance();
                arg = parseExpressionWithPrecedence(parser, 0, inline);
                if arg && arg.type == "ParseError" {
                    return arg;
                }
                args.push(arg);
            }
        }

        let rparen = parser.expect("RPAREN");
        if rparen && rparen.type == "ParseError" {
            return rparen;
        }

        let node = parser.mark_node("NewExpression");
        node.className = className.value;
        node.arguments = args;
        return node;
    }

    if parser.current_token.type == "LPAREN" {
        parser.advance();
        let expr = parseExpressionWithPrecedence(parser, 0, inline);
        if expr && expr.type == "ParseError" {
            return expr;
        }
        let rparen = parser.expect("RPAREN");
        if rparen && rparen.type == "ParseError" {
            return rparen;
        }
        return expr;
    }

    # 支持数组字面量 []
    if parser.current_token.type == "LBRACKET" {
        parser.advance();
        let node = parser.mark_node("ArrayLiteral");
        node.elements = [];

        if parser.current_token.type != "RBRACKET" {
            let element = parseExpressionWithPrecedence(parser, 0, inline);
            if element && element.type == "ParseError" {
                return element;
            }
            node.elements.push(element);

            while parser.current_token.type == "COMMA" {
                parser.advance();
                element = parseExpressionWithPrecedence(parser, 0, inline);
                if element && element.type == "ParseError" {
                    return element;
                }
                node.elements.push(element);
            }
        }

        let rbracket = parser.expect("RBRACKET");
        if rbracket && rbracket.type == "ParseError" {
            return rbracket;
        }

        return node;
    }

    # 支持对象字面量 {} - 只有在非 inline 模式下才解析
    if parser.current_token.type == "LBRACE" && !inline {
        parser.advance();
        let node = parser.mark_node("ObjectLiteral");
        node.properties = [];

        if parser.current_token.type != "RBRACE" {
            while parser.current_token.type == "SYMBOL_XID" || parser.current_token.type == "STRING" {
                let key = parser.current_token.value;
                parser.advance();
                let colon = parser.expect("COLON");
                if colon && colon.type == "ParseError" {
                    return colon;
                }
                let value = parseExpressionWithPrecedence(parser, 0, inline);
                if value && value.type == "ParseError" {
                    return value;
                }

                let propertyNode = parser.mark_node("Property");
                propertyNode.key = key;
                propertyNode.value = value;
                node.properties.push(propertyNode);

                if parser.current_token.type == "COMMA" {
                    parser.advance();
                } else {
                    break;
                }
            }
        }

        let rbrace = parser.expect("RBRACE");
        if rbrace && rbrace.type == "ParseError" {
            return rbrace;
        }

        return node;
    }

    # 如果没有匹配的主表达式，返回错误
    let error = {};
    error.type = "ParseError";
    error.message = "Expected expression but got " + parser.current_token.type;
    error.line = parser.current_token.line;
    error.column = parser.current_token.column;
    return error;
}

# 封装参数解析函数，供 micro function 和 method function 共享
micro parseTermParameters(parser: ValkyrieParser) -> Array<Node> {
    let params = [];

    if parser.current_token.type != "RPAREN" {
        # 解析第一个参数
        let param = parseTypedParameter(parser);
        if param && param.type == "ParseError" {
            return param;
        }
        params.push(param);

        while parser.current_token.type == "COMMA" {
            parser.advance(); # skip comma
            param = parseTypedParameter(parser);
            if param && param.type == "ParseError" {
                return param;
            }
            params.push(param);
        }
    }

    return params;
}

# 解析带类型注解的参数: name: Type = defaultValue
micro parseTypedParameter(parser: ValkyrieParser) -> Node {
    let paramName = null;
    if parser.current_token.type == "SYMBOL_XID" {
        paramName = parser.expect("SYMBOL_XID");
    } else if parser.current_token.type == "SELF" {
        paramName = parser.expect("SELF");
    } else {
        paramName = parser.expect("SYMBOL_XID");
    }
    
    if paramName && paramName.type == "ParseError" {
        return paramName;
    }

    let node = parser.mark_node("Parameter");
    node.name = paramName.value;
    node.typeAnnotation = null;
    node.defaultValue = null;

    # 检查类型注解 : Type
    if parser.current_token.type == "COLON" {
        parser.advance(); # skip ':'
        let typeExpr = parseTypeExpression(parser);
        if typeExpr && typeExpr.type == "ParseError" {
            return typeExpr;
        }
        node.typeAnnotation = typeExpr;
    }

    # 检查默认值 = value
    if parser.current_token.type == "ASSIGN" {
        parser.advance(); # skip '='
        let defaultExpr = parseExpression(parser);
        if defaultExpr && defaultExpr.type == "ParseError" {
            return defaultExpr;
        }
        node.defaultValue = defaultExpr;
    }

    return node;
}



