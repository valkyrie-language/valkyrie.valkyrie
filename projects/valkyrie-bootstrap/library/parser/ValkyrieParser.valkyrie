namespace package::parser;


class ValkyrieParser {
    constructor(options: CompilerOptions) {

    }

    micro advance(self) {
        self.position = self.position + 1;
        if self.position < self.tokens.length {
            self.current_token = self.tokens[self.position];
        }
        else {
            self.current_token = {};
            self.current_token.`type` = "EOF";
        }
    }
    
    micro expect(self, tokenType) {
        if self.current_token.`type` != tokenType {
            let error = {};
            error.`type` = "ParseError";
            error.message = "Expected " + tokenType + " but got " + self.current_token.`type`;
            error.line = self.current_token.line;
            error.column = self.current_token.column;
            return error;
        }
        let token = self.current_token;
        self.advance();
        return token;
    }

    micro make_node(self, node_type: String) {
        return new Node(node_type, self.current_token.offset, self.current_token.length, self.current_token.line, self.current_token.column);
    }

    micro parse(self, tokens: Array<Token>) -> Node {
        self.tokens = tokens;
        self.position = 0;
        self.current_token = tokens[0];
        return parse_program(self);
    }

    micro parse_identifier(self) {
        if self.current_token.`type` == "SYMBOL_XID" || self.current_token.`type` == "SYMBOL_RAW" {
            let token = self.current_token;
            self.advance();
            return token;
        }
        let error = {};
        error.`type` = "ParseError";
        error.message = "Expected identifier but got " + self.current_token.`type`;
        error.line = self.current_token.line;
        error.column = self.current_token.column;
        return error;
    }
    
    micro parse_identifier_in(self, context: String) {
        if self.current_token["type"] == "SYMBOL_XID" || self.current_token["type"] == "SYMBOL_RAW" {
            let token = self.current_token;
            self.advance();
            return token;
        }

        if context == "Branches" {
            if self.current_token["type"] == "TYPE" || self.current_token["type"] == "CASE" || self.current_token["type"] == "WHEN" || self.current_token["type"] == "ELSE" {
                let token = self.current_token;
                self.advance();
                return token;
            }
        }

        let error = {};
        error["type"] = "ParseError";
        error.message = "Expected identifier in context " + context + " but got " + self.current_token["type"];
        error.line = self.current_token.line;
        error.column = self.current_token.column;
        return error;
    }


    micro parse_name_path(self, free_mode: bool) -> NamePathNode {
        # 解析第一个标识符
        let first_identifier = self.parse_identifier();
        if first_identifier.`type` == "ParseError" {
            return first_identifier;
        }
        
        let names = [];
        let firstNode = self.make_node("Identifier");
        firstNode.name = first_identifier.value;
        names.push(firstNode);

        # 继续解析双冒号后面的部分
        while self.current_token.`type` == "DOUBLE_COLON" {
            self.advance(); # skip double colon

            # 解析下一个标识符
            if self.current_token.`type` != "SYMBOL_XID" && self.current_token.`type` != "SYMBOL_RAW" {
                let error = {};
                error.`type` = "ParseError";
                error.message = "Expected identifier after '::'";
                error.line = self.current_token.line;
                error.column = self.current_token.column;
                return error;
            }

            let nextName = self.current_token.value;
            self.advance();

            let nextIdentifier = self.make_node("Identifier");
            nextIdentifier.name = nextName;
            names.push(nextIdentifier);
        }
        let namepath = self.make_node("NamePath");
        namepath.name_path = names;
        return namepath;
    }

    # 可选的分号
    micro eat_semicolon(self) {
        if self.current_token.`type` == "SEMICOLON" {
            self.advance();
        }
    }
}