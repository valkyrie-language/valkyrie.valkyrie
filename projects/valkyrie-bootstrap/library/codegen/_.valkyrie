namespace package::codegen;

using package::parser::Node;
using package::codegen::JsCodeGeneration;
using package::codegen::replace_all;
using package::codegen::join_path;

# Valkyrie 代码生成器 - 重构为模块化版本，使用写缓冲区产生更易读的JavaScript输出

# Legacy compatibility functions for backward compatibility
micro joinPath(pathArray, separator) {
    return join_path(pathArray, separator);
}

micro replaceAll(str, search, replace) {
    return replace_all(str, search, replace);
}

# Enhanced expression generation using write buffer for better formatting
micro generateExpression(node) {
    if node.type == "Number" {
        return node.value;
    }
    
    if node.type == "String" {
        # 处理字符串转义，确保与bootstrap/codegen.js一致
        let escaped = node.value;
        # 替换反斜杠
        escaped = replace_all(escaped, "\\", "\\\\");
        # 替换双引号
        escaped = replace_all(escaped, "\"", "\\\"");
        # 替换换行符
        escaped = replace_all(escaped, "\n", "\\n");
        # 替换回车符
        escaped = replace_all(escaped, "\r", "\\r");
        # 替换制表符
        escaped = replace_all(escaped, "\t", "\\t");
        return "\"" + escaped + "\"";
    }
    
    if node.type == "Boolean" {
        return node.value;
    }
    
    if node.type == "Identifier" {
        return node.name;
    }
    
    if node.type == "BinaryOp" {
        let left = generateExpression(node.left);
        let right = generateExpression(node.right);
        let result = "(";
        result = result + left;
        result = result + " ";
        result = result + node.operator;
        result = result + " ";
        result = result + right;
        result = result + ")";
        return result;
    }
    
    if node.type == "Assignment" {
        let left = generateExpression(node.left);
        let right = generateExpression(node.right);
        return left + " = " + right;
    }
    
    if node.type == "MicroCall" {
        let callee = generateExpression(node.callee);
        let args = "";
        
        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + generateExpression(node.arguments[i]);
            i = i + 1;
        }
        
        # 检查是否有尾随闭包
        if node.closure {
            # 生成尾随闭包的 JavaScript 代码
            let closureParams = "";
            # 尾随闭包通常没有参数，或者参数在调用时推断
            
            let closureBody = "";
            if node.closure {
                # closure 是一个 Block 节点
                closureBody = generateStatement(node.closure);
            }
            
            # 如果有普通参数，添加逗号分隔
            if args.length > 0 {
                args = args + ", ";
            }
            args = args + "function(" + closureParams + ") " + closureBody;
        }
        
        return callee + "(" + args + ")";
    }
    
    if node.type == "AnonymousFunction" {
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            let param = node.parameters[i];
            if param && param.name {
                params = params + param.name;
            } else {
                params = params + param;
            }
            i = i + 1;
        }
        
        let body = "";
        if node.body {
            body = generateStatement(node.body);
        }
        
        return "function(" + params + ") " + body;
    }
    
    if node.type == "NewExpression" {
        let args = "";
        
        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + generateExpression(node.arguments[i]);
            i = i + 1;
        }
        
        # 检查是否有解析后的类名
        let className = node.className;
        if node.resolvedClassName {
            className = node.resolvedClassName;
        }
        
        return "new " + className + "(" + args + ")";
    }
    
    if node.type == "AwaitExpression" {
        let argument = generateExpression(node.argument);
        return "await " + argument;
    }
    
    if node.type == "PropertyAccess" {
        if node.object.type {
            let obj = generateExpression(node.object);
            return obj + "." + node.property;
        } else {
            return node.object + "." + node.property;
        }
    }
    
    if node.type == "StaticMethodCall" {
        let className = "";
        if node.namespacePath {
            # 使用新的namespacePath支持多级命名空间
            if node.namespacePath.length >= 2 {
                className = node.namespacePath[node.namespacePath.length - 2];
            } else {
                className = node.namespacePath[0];
            }
        } else if node.className.type {
            className = generateExpression(node.className);
        } else {
            className = node.className;
        }
        
        let args = "";
        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + generateExpression(node.arguments[i]);
            i = i + 1;
        }
        
        return className + "." + node.methodName + "(" + args + ")";
    }
    
    if node.type == "StaticPropertyAccess" {
        let className = "";
        if node.namespacePath {
            # 使用新的namespacePath支持多级命名空间
            if node.namespacePath.length >= 2 {
                className = node.namespacePath[node.namespacePath.length - 2];
            } else {
                className = node.namespacePath[0];
            }
        } else if node.className.type {
            className = generateExpression(node.className);
        } else {
            className = node.className;
        }
        
        return className + "." + node.property;
    }
    
    if node.type == "ArrayAccess" {
        let obj = "";
        if node.object.type {
            obj = generateExpression(node.object);
        } else {
            obj = node.object;
        }
        let index = generateExpression(node.index);
        return obj + "[" + index + "]";
    }
    
    if node.type == "ObjectLiteral" {
        if node.properties.length == 0 {
            return "{}";
        }
        let result = "{";
        let i = 0;
        while i < node.properties.length {
            let prop = node.properties[i];
            if i > 0 {
                result = result + ", ";
            }
            result = result + "\"" + prop.key + "\": " + generateExpression(prop.value);
            i = i + 1;
        }
        result = result + "}";
        return result;
    }
    
    if node.type == "ArrayLiteral" {
        return "[]";
    }
    
    if node.type == "UnaryOp" {
        let operand = generateExpression(node.operand);
        return node.operator + operand;
    }
    
    if node.type == "ThisExpression" {
        return "this";
    }
    
    if node.type == "DefaultValue" {
        return "undefined";
    }
    
micro generateStatement(node) {
    if node.type == "LetStatement" {
        let value = generateExpression(node.value);
        return "let " + node.name + " = " + value + ";";
    }

    if node.type == "NamespaceStatement" {
        # namespace 语句在单文件编译中被忽略，在多文件编译中用于符号管理
        let namespacePath = join_path(node.path, "::");
        if node.isMainNamespace {
            return "// namespace! " + namespacePath + ";";
        } else {
            return "// namespace " + namespacePath + ";";
        }
    }

    if node.type == "UsingStatement" {
        # using 语句在整合编译中被忽略，在多文件编译中用于符号导入
        return "// using " + join_path(node.path, "::") + ";";
    }

    if node.type == "JSAttributeStatement" {
        # 生成 JS 导入语句：import {importName as functionName} from "modulePath"
        return "import { " + node.importName + " as " + node.functionName + " } from \"" + node.modulePath + "\";";
    }

    if node.type == "ImportJsStatement" {
        # 生成 JS 导入语句：import {importName as localName} from "module"
        return "import { " + node.importName + " as " + node.localName + " } from \"" + node.module + "\";";
    }

    if node.type == "MicroDeclaration" {
        # 使用写缓冲区生成更好格式的函数定义
        let buffer = new JsCodeGeneration();
        
        buffer.write("export function " + node.name + "(");
        
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                buffer.write(", ");
            }
            # 处理新的 Parameter 节点结构
            let param = node.parameters[i];
            if param && param.name {
                buffer.write(param.name);
            } else {
                # 兼容旧的字符串格式
                buffer.write(param);
            }
            i = i + 1;
        }
        
        buffer.write(") ");
        let body = generateStatement(node.body);
        buffer.write(body);
        
        return buffer.toString();
    }
    
    if node.type == "MemberStatement" {
        let buffer = new JsCodeGeneration();
        
        buffer.write("function " + node.name + "(");
        
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                buffer.write(", ");
            }
            # 处理新的 Parameter 节点结构
            let param = node.parameters[i];
            if param && param.name {
                buffer.write(param.name);
            } else {
                # 兼容旧的字符串格式
                buffer.write(param);
            }
            i = i + 1;
        }
        
        buffer.write(") ");
        let body = generateStatement(node.body);
        buffer.write(body);
        
        return buffer.toString();
    }
    
    if node.type == "IfStatement" {
        let condition = generateExpression(node.condition);
        let thenBranch = generateStatement(node.thenBranch);
        let result = "if (" + condition + ") " + thenBranch;
        
        if node.elseBranch && node.elseBranch.type {
            let elseBranch = generateStatement(node.elseBranch);
            result = result + " else " + elseBranch;
        }
        
        return result;
    }
    
    if node.type == "WhileStatement" {
        let condition = generateExpression(node.condition);
        let body = generateStatement(node.body);
        return "while (" + condition + ") " + body;
    }
    
    if node.type == "UntilStatement" {
        let condition = generateExpression(node.condition);
        let body = generateStatement(node.body);
        return "while (!(" + condition + ")) " + body;
    }
    
    if node.type == "ReturnStatement" {
        if node.value && node.value.type {
            let value = generateExpression(node.value);
            return "return " + value + ";";
        } else {
            return "return;";
        }
    }
    
    if node.type == "Block" {
        # 使用写缓冲区生成更好格式的代码块
        let buffer = new JsCodeGeneration();
        
        buffer.write_line("{");
        buffer.indent();
        
        let i = 0;
        while i < node.statements.length {
            let stmt = generateStatement(node.statements[i]);
            buffer.write_line(stmt);
            i = i + 1;
        }
        
        buffer.dedent();
        buffer.write("}");
        
        return buffer.toString();
    }
    
    if node.type == "ExpressionStatement" {
        return generateExpression(node.expression) + ";";
    }
    
    if node.type == "JSAttributeStatement" {
        # 生成 JS 导入语句和函数定义
        let cleanImportName = replace_all(node.importName, "-", "_");
        cleanImportName = replace_all(cleanImportName, ".", "_");
        cleanImportName = replace_all(cleanImportName, "/", "_");
        let uniqueName = node.functionName + "_" + cleanImportName;
        let importStatement = "import { " + node.importName + " as " + uniqueName + " } from \"" + node.modulePath + "\";";
        
        # 生成函数包装
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            params = params + node.parameters[i];
            i = i + 1;
        }
        
        let buffer = new JsCodeGeneration();
        buffer.write_line(importStatement);
        buffer.write_line("export function " + node.functionName + "(" + params + ") {");
        buffer.indent();
        buffer.write_line("return " + uniqueName + "(" + params + ");");
        buffer.dedent();
        buffer.write("}");
        
        return buffer.toString();
    }
    
    if node.type == "ClassDeclaration" {
        # 使用写缓冲区生成更好格式的类定义
        let buffer = new JsCodeGeneration();
        
        let className = node.name;
        let superClass = node.superClass;
        let members = node.members;
        
        buffer.write("class " + className);
        
        # 添加继承
        if superClass {
            buffer.write(" extends " + superClass);
        }
        
        buffer.write_line(" {");
        buffer.indent();
        
        # 检查是否有显式构造函数
        let hasExplicitConstructor = false;
        let explicitConstructor = null;
        let fieldInits = [];
        let i = 0;
        while i < members.length {
            let member = members[i];
            if member.type == "ConstructorStatement" {
                hasExplicitConstructor = true;
                explicitConstructor = member;
            } else if member.type == "Property" {
                fieldInits.push(member);
            }
            i = i + 1;
        }
        
        # 生成构造函数
        if hasExplicitConstructor || fieldInits.length > 0 {
            buffer.write("constructor(");
            
            if hasExplicitConstructor {
                let j = 0;
                while j < explicitConstructor.parameters.length {
                    if j > 0 {
                        buffer.write(", ");
                    }
                    # 处理新的 Parameter 节点结构
                    let param = explicitConstructor.parameters[j];
                    if param && param.name {
                        buffer.write(param.name);
                    } else {
                        # 兼容旧的字符串格式
                        buffer.write(param);
                    }
                    j = j + 1;
                }
            }
            
            buffer.write_line(") {");
            buffer.indent();
            
            if superClass {
                buffer.write_line("super();");
            }
            
            # 初始化字段
            let k = 0;
            while k < fieldInits.length {
                let field = fieldInits[k];
                if field.initializer && field.initializer.type {
                    let initValue = generateExpression(field.initializer);
                    buffer.write_line("this." + field.name + " = " + initValue + ";");
                } else {
                    buffer.write_line("this." + field.name + " = undefined;");
                }
                k = k + 1;
            }
            
            # 添加构造函数体
            if hasExplicitConstructor && explicitConstructor.body {
                let ctorBody = generateStatement(explicitConstructor.body);
                # 移除外层的大括号，只保留内容
                if ctorBody.startsWith("{\n") && ctorBody.endsWith("\n}") {
                    ctorBody = ctorBody.substring(2, ctorBody.length - 2);
                }
                buffer.write_line(ctorBody);
            }
            
            buffer.dedent();
            buffer.write_line("}");
            buffer.write_line("");
        }
        
        # 生成类方法
        i = 0;
        while i < members.length {
            let member = members[i];
            if member.type == "MemberStatement" {
                let methodName = member.name;
                
                if member.isStatic {
                    buffer.write("static ");
                }
                
                buffer.write(methodName + "(");
                
                let m = 0;
                let paramCount = 0;
                while m < member.parameters.length {
                    # 跳过 self 参数，因为在 ES6 class 中不需要显式的 self
                    let param = member.parameters[m];
                    let paramName = "";
                    
                    # 处理新的 Parameter 节点结构
                    if param && param.name {
                        paramName = param.name;
                    } else {
                        # 兼容旧的字符串格式
                        paramName = param;
                    }
                    
                    if paramName != "self" {
                        if paramCount > 0 {
                            buffer.write(", ");
                        }
                        buffer.write(paramName);
                        paramCount = paramCount + 1;
                    }
                    m = m + 1;
                }
                buffer.write(") ");
                let body = generateStatement(member.body);
                buffer.write_line(body);
                buffer.write_line("");
            }
            i = i + 1;
        }
        
        buffer.dedent();
        buffer.write("}");
        
        return buffer.toString();
    }
    
micro generate(ast) {
    if ast.type == "Program" {
        # 使用写缓冲区生成更好格式的程序
        let buffer = new JsCodeGeneration();
        
        let i = 0;
        while i < ast.statements.length {
            let stmt = ast.statements[i];
            let stmtCode = generateStatement(stmt);
            buffer.write_line(stmtCode);
            i = i + 1;
        }
        
        return buffer.toString();
    }
    
    if ast.type == "ParseError" {
        return "// Parse Error: " + ast.message + " at line " + ast.line + ", column " + ast.column;
    }
    
    return generateStatement(ast);
}