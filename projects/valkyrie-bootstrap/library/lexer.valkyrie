namespace package::lexer;

# Valkyrie 词法分析器 - 超简单版本
class ValkyrieLexer {
    constructor(source) {
        self.source = source;
        self.position = 0;
        self.line = 1;
        self.column = 1;
        self.current_char = "";

        if source.length > 0 {
            self.current_char = source.charAt(0);
        }
    }
    micro advance(self) {
        if self.current_char == "\n" {
            self.line = self.line + 1;
            self.column = 1;
        } else {
            self.column = self.column + 1;
        }

        self.position = self.position + 1;

        if self.position >= self.source.length {
            self.current_char = "";
        } else {
            self.current_char = self.source.charAt(self.position);
        }
    }
}

class Token {
    constructor(type, value, line, column) {
        self.type = type;
        self.value = value;
        self.line = line;
        self.column = column;
    }
}

micro skipWhitespace(lexer) {
    while lexer.current_char != "" && isWhitespace(lexer.current_char) {
        lexer.advance();
    }
}

micro isWhitespace(ch) {
    return ch == " " || ch == "\t" || ch == "\n" || ch == "\r";
}

micro isAlpha(ch) {
    return (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || ch == "_";
}

micro isDigit(ch) {
    return ch >= "0" && ch <= "9";
}

micro isAlphaNumeric(ch) {
    return isAlpha(ch) || isDigit(ch);
}

micro readIdentifier(lexer) {
    let result = "";
    
    while lexer.current_char != "" && isAlphaNumeric(lexer.current_char) {
        result = result + lexer.current_char;
        lexer.advance();
    }
    
    return result;
}

micro readNumber(lexer) {
    let result = "";
    
    while lexer.current_char != "" && isDigit(lexer.current_char) {
        result = result + lexer.current_char;
        lexer.advance();
    }
    
    return result;
}

micro readString(lexer) {
    let result = "";
    lexer.advance(); # skip opening quote
    
    while lexer.current_char != "" && lexer.current_char != "\"" {
        if lexer.current_char == "\\" {
            lexer.advance(); # consume '\'
            if lexer.current_char == "n" {
                result = result + "\n";
            } else {
                if lexer.current_char == "t" {
                    result = result + "\t";
                } else {
                    if lexer.current_char == "r" {
                        result = result + "\r";
                    } else {
                        if lexer.current_char == "\"" {
                            result = result + "\"";
                        } else {
                            if lexer.current_char == "\\" {
                                result = result + "\\";
                            } else {
                                result = result + "\\" + lexer.current_char;
                            }
                        }
                    }
                }
            }
        } else {
            result = result + lexer.current_char;
        }
        lexer.advance();
    }
    
    if lexer.current_char == "\"" {
        lexer.advance(); # skip closing quote
    }
    
    return result;
}

micro skipComment(lexer) {
    while lexer.current_char != "" && lexer.current_char != "\n" {
        lexer.advance();
    }
}

micro getKeywordType(value) {
    if value == "micro" { return "MICRO"; }
    if value == "let" { return "LET"; }
    if value == "if" { return "IF"; }
    if value == "else" { return "ELSE"; }
    if value == "while" { return "WHILE"; }
    if value == "return" { return "RETURN"; }
    if value == "true" { return "BOOLEAN"; }
    if value == "false" { return "BOOLEAN"; }
    if value == "namespace" { return "NAMESPACE"; }
    if value == "using" { return "USING"; }
    if value == "class" { return "CLASS"; }
    if value == "constructor" { return "CONSTRUCTOR"; }
    if value == "self" { return "SELF"; }
    if value == "extends" { return "EXTENDS"; }
    if value == "implements" { return "IMPLEMENTS"; }
    if value == "new" { return "NEW"; }
    if value == "default" { return "DEFAULT"; }
    if value == "await" { return "AWAIT"; }
    return "IDENTIFIER";
}



micro nextToken(lexer) {
    while lexer.current_char != "" {
        if isWhitespace(lexer.current_char) {
            skipWhitespace(lexer);
            continue;
        }
        
        if lexer.current_char == "#" {
            skipComment(lexer);
            continue;
        }
        
        let line = lexer.line;
        let column = lexer.column;
        
        if isAlpha(lexer.current_char) {
            let value = readIdentifier(lexer);
            let tokenType = getKeywordType(value);
            return new Token(tokenType, value, line, column);
        }
        
        if isDigit(lexer.current_char) {
            let value = readNumber(lexer);
            return new Token("NUMBER", value, line, column);
        }
        
        if lexer.current_char == "\"" {
            let value = readString(lexer);
            return new Token("STRING", value, line, column);
        }
        
        # Single character tokens
        let ch = lexer.current_char;
        lexer.advance();
        
        if ch == "{" { return new Token("LBRACE", ch, line, column); }
        if ch == "}" { return new Token("RBRACE", ch, line, column); }
        if ch == "(" { return new Token("LPAREN", ch, line, column); }
        if ch == ")" { return new Token("RPAREN", ch, line, column); }
        if ch == "[" { return new Token("LBRACKET", ch, line, column); }
        if ch == "]" { return new Token("RBRACKET", ch, line, column); }
        if ch == ";" { return new Token("SEMICOLON", ch, line, column); }
        if ch == "," { return new Token("COMMA", ch, line, column); }
        if ch == ":" {
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == ":" {
                lexer.advance();
                return new Token("DOUBLE_COLON", "::", line, column);
            }
            return new Token("COLON", ch, line, column);
        }
        if ch == "=" {
            # 检查是否是 == 操作符
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "=" {
                lexer.advance();
                return new Token("EQ", "==", line, column);
            }
            return new Token("ASSIGN", ch, line, column);
        }
        if ch == "+" { return new Token("PLUS", ch, line, column); }
        if ch == "-" { return new Token("MINUS", ch, line, column); }
        if ch == "*" { return new Token("MULTIPLY", ch, line, column); }
        if ch == "/" { return new Token("DIVIDE", ch, line, column); }
        if ch == "%" { return new Token("MODULO", ch, line, column); }
        if ch == "&" { 
            # 检查是否是 &&
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "&" {
                lexer.advance(); # 跳过第二个 &
                return new Token("AND", "&&", line, column);
            }
            return new Token("AMPERSAND", ch, line, column);
        }
        if ch == "|" { 
            # 检查是否是 ||
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "|" {
                lexer.advance(); # 跳过第二个 |
                return new Token("OR", "||", line, column);
            }
            return new Token("PIPE", ch, line, column);
        }
        if ch == ">" { 
            # 检查是否是 >=
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "=" {
                lexer.advance(); # 跳过 =
                return new Token("GTE", ">=", line, column);
            }
            return new Token("GT", ch, line, column);
        }
        if ch == "<" { 
            # 检查是否是 <=
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "=" {
                lexer.advance(); # 跳过 =
                return new Token("LTE", "<=", line, column);
            }
            return new Token("LT", ch, line, column);
        }
        if ch == "!" { 
            # 检查是否是 !=
            if lexer.position < lexer.source.length && lexer.source.charAt(lexer.position) == "=" {
                lexer.advance(); # 跳过 =
                return new Token("NE", "!=", line, column);
            }
            return new Token("BANG", ch, line, column);
        }
        if ch == "." { return new Token("DOT", ch, line, column); }
        if ch == "↯" { return new Token("ATTRIBUTE", ch, line, column); }
        
        # Unknown character
        return new Token("ERROR", "Unknown character: " + ch, line, column);
    }
    
    return new Token("EOF", "", lexer.line, lexer.column);
}

micro tokenize(lexer) {
    let tokens = [];
    
    while true {
        let token = nextToken(lexer);
        tokens.push(token);
        
        if token.type == "EOF" {
            break;
        }
    }
    
    return tokens;
}