namespace package::lexer;

# Valkyrie 词法分析器
class ValkyrieLexer {
    constructor(source) {
        self.source = source;
        self.position = 0;
        self.line = 1;
        self.column = 1;
        self.current_char = "";

        if source.length > 0 {
            self.current_char = source.charAt(0);
        }
    }
    micro advance(self) {
        if self.current_char == "\n" {
            self.line = self.line + 1;
            self.column = 1;
        } else {
            self.column = self.column + 1;
        }

        self.position = self.position + 1;

        if self.position >= self.source.length {
            self.current_char = "";
        } else {
            self.current_char = self.source.charAt(self.position);
        }
    }

    micro skip_whitespace(self) {
        while self.current_char != "" && is_whitespace(self.current_char) {
            self.advance();
        }
    }

    micro read_number(self) {
        let result = "";

        while self.current_char != "" && is_digit(self.current_char) {
            result = result + self.current_char;
            self.advance();
        }

        return result;
    }

    micro read_identifier(self) {
        let result = "";

        while self.current_char != "" && is_alpha_numeric(self.current_char) {
            result = result + self.current_char;
            self.advance();
        }

        return result;
    }

    micro read_raw_identifier(self) {
        let result = "";
        self.advance(); # skip opening backtick

        while self.current_char != "" && self.current_char != "`" {
            result = result + self.current_char;
            self.advance();
        }

        if self.current_char == "`" {
            self.advance(); # skip closing backtick
        }

        return result;
    }

    micro read_string(self) {
        let result = "";
        self.advance(); # skip opening quote

        while self.current_char != "" && self.current_char != "\"" {
            if self.current_char == "\\" {
                self.advance(); # consume '\'
                if self.current_char == "n" {
                    result = result + "\n";
                } else {
                    if self.current_char == "t" {
                        result = result + "\t";
                    } else {
                        if self.current_char == "r" {
                            result = result + "\r";
                        } else {
                            if self.current_char == "\"" {
                                result = result + "\"";
                            } else {
                                if self.current_char == "\\" {
                                    result = result + "\\";
                                } else {
                                    result = result + "\\" + self.current_char;
                                }
                            }
                        }
                    }
                }
            } else {
                result = result + self.current_char;
            }
            self.advance();
        }

        if self.current_char == "\"" {
            self.advance(); # skip closing quote
        }

        return result;
    }

    micro skip_comment(self) {
        while self.current_char != "" && self.current_char != "\n" {
            self.advance();
        }
    }

    micro next_token(self) {
        while self.current_char != "" {
            if is_whitespace(self.current_char) {
                self.skip_whitespace();
                continue;
            }

            if self.current_char == "#" {
                self.skip_comment();
                continue;
            }

            let line = self.line;
            let column = self.column;

            if is_alpha(self.current_char) {
                let value = self.read_identifier();
                let tokenType = get_keyword_type(value);
                return new Token(tokenType, value, line, column);
            }

            if is_digit(self.current_char) {
                let value = self.read_number();
                return new Token("NUMBER", value, line, column);
            }

            if self.current_char == "\"" {
                let value = self.read_string();
                return new Token("STRING", value, line, column);
            }

            if self.current_char == "`" {
                let value = self.read_raw_identifier();
                return new Token("SYMBOL_RAW", value, line, column);
            }

            # Single character tokens
            let ch = self.current_char;
            self.advance();

            if ch == "{" { return new Token("LBRACE", ch, line, column); }
            if ch == "}" { return new Token("RBRACE", ch, line, column); }
            if ch == "(" { return new Token("LPAREN", ch, line, column); }
            if ch == ")" { return new Token("RPAREN", ch, line, column); }
            if ch == "[" { return new Token("LBRACKET", ch, line, column); }
            if ch == "]" { return new Token("RBRACKET", ch, line, column); }
            if ch == ";" { return new Token("SEMICOLON", ch, line, column); }
            if ch == "," { return new Token("COMMA", ch, line, column); }
            if ch == ":" {
                if self.position < self.source.length && self.source.charAt(self.position) == ":" {
                    self.advance();
                    return new Token("DOUBLE_COLON", "::", line, column);
                }
                return new Token("COLON", ch, line, column);
            }
            if ch == "=" {
                # 检查是否是 == 操作符
                if self.position < self.source.length && self.source.charAt(self.position) == "=" {
                    self.advance();
                    return new Token("EQ", "==", line, column);
                }
                return new Token("ASSIGN", ch, line, column);
            }
            if ch == "+" { return new Token("PLUS", ch, line, column); }
            if ch == "-" { 
                # 检查是否是 ->
                if self.position < self.source.length && self.source.charAt(self.position) == ">" {
                    self.advance(); # 跳过 >
                    return new Token("ARROW", "->", line, column);
                }
                return new Token("MINUS", ch, line, column); 
            }
            if ch == "*" { return new Token("MULTIPLY", ch, line, column); }
            if ch == "/" { return new Token("DIVIDE", ch, line, column); }
            if ch == "%" { return new Token("MODULO", ch, line, column); }
            if ch == "&" {
                # 检查是否是 &&
                if self.position < self.source.length && self.source.charAt(self.position) == "&" {
                    self.advance(); # 跳过第二个 &
                    return new Token("AND", "&&", line, column);
                }
                return new Token("AMPERSAND", ch, line, column);
            }
            if ch == "|" {
                # 检查是否是 ||
                if self.position < self.source.length && self.source.charAt(self.position) == "|" {
                    self.advance(); # 跳过第二个 |
                    return new Token("OR", "||", line, column);
                }
                return new Token("PIPE", ch, line, column);
            }
            if ch == ">" {
                # 检查是否是 >=
                if self.position < self.source.length && self.source.charAt(self.position) == "=" {
                    self.advance(); # 跳过 =
                    return new Token("GTE", ">=", line, column);
                }
                return new Token("GT", ch, line, column);
            }
            if ch == "<" {
                # 检查是否是 <=
                if self.position < self.source.length && self.source.charAt(self.position) == "=" {
                    self.advance(); # 跳过 =
                    return new Token("LTE", "<=", line, column);
                }
                return new Token("LT", ch, line, column);
            }
            if ch == "!" {
                # 检查是否是 !=
                if self.position < self.source.length && self.source.charAt(self.position) == "=" {
                    self.advance(); # 跳过 =
                    return new Token("NE", "!=", line, column);
                }
                return new Token("BANG", ch, line, column);
            }
            if ch == "?" { return new Token("QUESTION", ch, line, column); }
            if ch == "." { return new Token("DOT", ch, line, column); }
            if ch == "↯" { return new Token("ATTRIBUTE", ch, line, column); }

            # Unknown character
            return new Token("ERROR", "Unknown character: " + ch, line, column);
        }

        return new Token("EOF", "", self.line, self.column);
    }

    micro tokenize(self) {
        let tokens = [];

        while true {
            let token = self.next_token();
            tokens.push(token);

            if token.`type` == "EOF" {
                break;
            }
        }

        return tokens;
    }
}

micro is_whitespace(ch: String) -> Bool {
    return ch == " " || ch == "\t" || ch == "\n" || ch == "\r";
}

micro is_alpha_numeric(ch: String) -> Bool {
    return is_alpha(ch) || is_digit(ch);
}

micro is_alpha(ch: String) -> Bool {
    return (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || ch == "_";
}

micro is_digit(ch: String) -> Bool {
    return ch >= "0" && ch <= "9";
}

micro get_keyword_type(value: String) -> String {
    match value {
        case "micro": return "MICRO";
        case "let": return "LET";
        case "if": return "IF";
        case "else": return "ELSE";
        case "while": return "WHILE";
        case "until": return "UNTIL";
        case "return": return "RETURN";
        case "true": return "BOOLEAN";
        case "false": return "BOOLEAN";
        case "namespace": return "NAMESPACE";
        case "using": return "USING";
        case "class": return "CLASS";
        case "singleton": return "SINGLETON";
        case "trait": return "TRAIT";
        case "constructor": return "CONSTRUCTOR";
        case "self": return "SELF";
        case "extends": return "EXTENDS";
        case "implements": return "IMPLEMENTS";
        case "new": return "NEW";
        case "default": return "DEFAULT";
        case "await": return "AWAIT";
        case "is": return "IS";
        case "as": return "AS";
        case "match": return "MATCH";
        case "when": return "WHEN";
        case "case": return "CASE";
        case "type": return "TYPE";
        else: return "SYMBOL_XID";
    };
}
