# Valkyrie 代码生成器
# 使用 Valkyrie 语言实现，生成 JavaScript 代码

# 导入 AST 模块
# namepath package
# using ast

# 代码生成器类
let CodeGenerator = {
    output = "",
    indentLevel = 0
}

# 初始化代码生成器
micro initCodeGenerator() {
    let generator = {}
    generator.output = ""
    generator.indentLevel = 0
    generator
}

# 添加缩进
micro addIndent(generator) {
    let indent = ""
    let i = 0
    while i < generator.indentLevel {
        indent = indent + "  "
        i = i + 1
    }
    indent
}

# 写入代码
micro write(generator, code) {
    generator.output = generator.output + code
    generator
}

# 写入带缩进的代码行
micro writeLine(generator, code) {
    generator.output = generator.output + addIndent(generator) + code + "\n"
    generator
}

# 增加缩进级别
micro increaseIndent(generator) {
    generator.indentLevel = generator.indentLevel + 1
    generator
}

# 减少缩进级别
micro decreaseIndent(generator) {
    if generator.indentLevel > 0 {
        generator.indentLevel = generator.indentLevel - 1
    }
    generator
}

# 生成程序代码
micro generateProgram(generator, node) {
    writeLine(generator, "// Generated by Valkyrie Compiler")
    writeLine(generator, "")
    
    let i = 0
    while i < node.statements.length {
        generateStatement(generator, node.statements[i])
        i = i + 1
    }
    
    generator
}

# 生成语句代码
micro generateStatement(generator, node) {
    if node.type == "VariableDeclaration" {
        generateVariableDeclaration(generator, node)
    } else if node.type == "FunctionDeclaration" {
        generateFunctionDeclaration(generator, node)
    } else if node.type == "IfStatement" {
        generateIfStatement(generator, node)
    } else if node.type == "BlockStatement" {
        generateBlockStatement(generator, node)
    } else if node.type == "ExpressionStatement" {
        generateExpressionStatement(generator, node)
    }
    
    generator
}

# 生成变量声明代码
micro generateVariableDeclaration(generator, node) {
    write(generator, addIndent(generator) + "let " + node.name + " = ")
    generateExpression(generator, node.initializer)
    writeLine(generator, ";")
    generator
}

# 生成函数声明代码
micro generateFunctionDeclaration(generator, node) {
    write(generator, addIndent(generator) + "function " + node.name + "(")
    
    # 生成参数列表
    let i = 0
    while i < node.parameters.length {
        if i > 0 {
            write(generator, ", ")
        }
        write(generator, node.parameters[i].name)
        i = i + 1
    }
    
    writeLine(generator, ") {")
    increaseIndent(generator)
    generateStatement(generator, node.body)
    decreaseIndent(generator)
    writeLine(generator, "}")
    writeLine(generator, "")
    
    generator
}

# 生成 If 语句代码
micro generateIfStatement(generator, node) {
    write(generator, addIndent(generator) + "if (")
    generateExpression(generator, node.condition)
    writeLine(generator, ") {")
    
    increaseIndent(generator)
    generateStatement(generator, node.thenBranch)
    decreaseIndent(generator)
    
    if node.elseBranch.type != "" {
        if node.elseBranch.type == "IfStatement" {
            write(generator, addIndent(generator) + "} else ")
            generateIfStatement(generator, node.elseBranch)
        } else {
            writeLine(generator, "} else {")
            increaseIndent(generator)
            generateStatement(generator, node.elseBranch)
            decreaseIndent(generator)
            writeLine(generator, "}")
        }
    } else {
        writeLine(generator, "}")
    }
    
    generator
}

# 生成块语句代码
micro generateBlockStatement(generator, node) {
    let i = 0
    while i < node.statements.length {
        generateStatement(generator, node.statements[i])
        i = i + 1
    }
    generator
}

# 生成表达式语句代码
micro generateExpressionStatement(generator, node) {
    write(generator, addIndent(generator))
    generateExpression(generator, node.expression)
    writeLine(generator, ";")
    generator
}

# 生成表达式代码
micro generateExpression(generator, node) {
    if node.type == "AssignmentExpression" {
        generateAssignmentExpression(generator, node)
    } else if node.type == "BinaryExpression" {
        generateBinaryExpression(generator, node)
    } else if node.type == "UnaryExpression" {
        generateUnaryExpression(generator, node)
    } else if node.type == "CallExpression" {
        generateCallExpression(generator, node)
    } else if node.type == "Identifier" {
        generateIdentifier(generator, node)
    } else if node.type == "NumberLiteral" {
        generateNumberLiteral(generator, node)
    } else if node.type == "StringLiteral" {
        generateStringLiteral(generator, node)
    } else if node.type == "BooleanLiteral" {
        generateBooleanLiteral(generator, node)
    } else if node.type == "ObjectLiteral" {
        generateObjectLiteral(generator, node)
    }
    
    generator
}

# 生成赋值表达式代码
micro generateAssignmentExpression(generator, node) {
    generateExpression(generator, node.left)
    write(generator, " = ")
    generateExpression(generator, node.right)
    generator
}

# 运算符映射表
let operatorMap = {
    "PLUS" = "+",
    "MINUS" = "-",
    "MULTIPLY" = "*",
    "DIVIDE" = "/",
    "MODULO" = "%",
    "EQUAL" = "==",
    "NOT_EQUAL" = "!=",
    "LESS" = "<",
    "GREATER" = ">",
    "LESS_EQUAL" = "<=",
    "GREATER_EQUAL" = ">=",
    "AND" = "&&",
    "OR" = "||",
    "NOT" = "!",
    "ASSIGN" = "=",
}

# 获取运算符符号
micro getOperatorSymbol(operator) {
    if operatorMap[operator] {
        operatorMap[operator]
    } else {
        operator
    }
}

# 生成二元表达式代码
micro generateBinaryExpression(generator, node) {
    write(generator, "(")
    generateExpression(generator, node.left)
    let opSymbol = getOperatorSymbol(node.operator)
    write(generator, " " + opSymbol + " ")
    generateExpression(generator, node.right)
    write(generator, ")")
    generator
}

# 生成一元表达式代码
micro generateUnaryExpression(generator, node) {
    let opSymbol = getOperatorSymbol(node.operator)
    write(generator, opSymbol)
    generateExpression(generator, node.operand)
    generator
}

# 生成函数调用表达式代码
micro generateCallExpression(generator, node) {
    generateExpression(generator, node.callee)
    write(generator, "(")
    
    let i = 0
    while i < node.arguments.length {
        if i > 0 {
            write(generator, ", ")
        }
        generateExpression(generator, node.arguments[i])
        i = i + 1
    }
    
    write(generator, ")")
    generator
}

# 生成标识符代码
micro generateIdentifier(generator, node) {
    write(generator, node.name)
    generator
}

# 生成数字字面量代码
micro generateNumberLiteral(generator, node) {
    write(generator, node.value)
    generator
}

# 生成字符串字面量代码
micro generateStringLiteral(generator, node) {
    write(generator, "\"" + node.value + "\"")
    generator
}

# 生成布尔字面量代码
micro generateBooleanLiteral(generator, node) {
    if node.value {
        write(generator, "true")
    } else {
        write(generator, "false")
    }
    generator
}

# 生成对象字面量代码
micro generateObjectLiteral(generator, node) {
    write(generator, "{")
    
    let i = 0
    while i < node.properties.length {
        if i > 0 {
            write(generator, ", ")
        }
        
        # 生成属性键值对
        let property = node.properties[i]
        write(generator, property.key + ": ")
        generateExpression(generator, property.value)
        
        i = i + 1
    }
    
    write(generator, "}")
    generator
}

# 代码生成主函数
micro generate(ast) {
    let generator = initCodeGenerator()
    generateProgram(generator, ast)
    generator.output
}