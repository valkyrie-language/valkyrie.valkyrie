# Valkyrie 代码生成器
# 使用 Valkyrie 语言实现，生成 JavaScript 代码

# 导入 AST 模块
# namepath package.codegen
# using ast.*

# 初始化代码生成器
micro initCodeGenerator() {
    let generator = {}
    generator.output = ""
    generator.indentLevel = 0
    return generator
}

# 添加缩进
micro addIndent(generator) {
    let indent = ""
    let i = 0
    while i < generator.indentLevel {
        indent = indent + "  "
        i = i + 1
    }
    return indent
}

# 写入代码
micro write(generator, code) {
    generator.output = generator.output + code
    return generator
}

# 写入带缩进的代码行
micro writeLine(generator, code) {
    let indent = addIndent(generator)
    generator.output = generator.output + indent + code + "\n"
    return generator
}

# 增加缩进级别
micro increaseIndent(generator) {
    generator.indentLevel = generator.indentLevel + 1
    return generator
}

# 减少缩进级别
micro decreaseIndent(generator) {
    if generator.indentLevel > 0 {
        generator.indentLevel = generator.indentLevel - 1
    }
    return generator
}

# 生成程序代码
micro generateProgram(generator, node) {
    # 生成运行时支持代码
    writeLine(generator, "// Valkyrie Runtime Support")
    writeLine(generator, "let ValkyrieRuntime = {")
    writeLine(generator, "    print: console.log,")
    writeLine(generator, "    assert: (condition, message) => {")
    writeLine(generator, "        if (!condition) throw new Error(message || \"Assertion failed\");")
    writeLine(generator, "    }")
    writeLine(generator, "};")
    writeLine(generator, "")
    writeLine(generator, "let CodeGenerator = {output: \"\", indentLevel: 0};")
    writeLine(generator, "")
    
    let i = 0
    while i < node.statements.length {
        generateStatement(generator, node.statements[i])
        i = i + 1
    }
    return generator
}

# 生成语句代码
micro generateStatement(generator, node) {
    if node.type == "VariableDeclaration" {
        generateVariableDeclaration(generator, node)
    } else if node.type == "FunctionDeclaration" {
        generateFunctionDeclaration(generator, node)
    } else if node.type == "ExportStatement" {
        generateExportStatement(generator, node)
    } else if node.type == "WhileStatement" {
        generateWhileStatement(generator, node)
    } else if node.type == "IfStatement" {
        generateIfStatement(generator, node)
    } else if node.type == "BlockStatement" {
        generateBlockStatement(generator, node)
    } else if node.type == "ReturnStatement" {
        generateReturnStatement(generator, node)
    } else if node.type == "ExpressionStatement" {
        generateExpressionStatement(generator, node)
    } else {
        # 空节点或未知节点类型，不生成任何代码
    }
    return generator
}

# 生成变量声明代码
micro generateVariableDeclaration(generator, node) {
    write(generator, addIndent(generator) + "let " + node.name + " = ")
    generateExpression(generator, node.initializer)
    writeLine(generator, ";")
    return generator
}

# 生成函数声明代码
micro generateFunctionDeclaration(generator, node) {
    write(generator, addIndent(generator) + "function " + node.name + "(")

    # 生成参数列表
    let i = 0
    while i < node.parameters.length {
        if i > 0 {
            write(generator, ", ")
        }
        if node.parameters[i].name != "" {
            write(generator, node.parameters[i].name)
        }
        i = i + 1
    }
    writeLine(generator, ") {")
    increaseIndent(generator)
    if node.body.type == "BlockStatement" {
        generateFunctionBody(generator, node.body)
    } else {
        generateStatement(generator, node.body)
    }
    decreaseIndent(generator)
    writeLine(generator, "}")
    writeLine(generator, "")
    return generator
}

# 生成 If 语句代码
micro generateIfStatement(generator, node) {
    write(generator, addIndent(generator) + "if (")
    generateExpression(generator, node.condition)
    writeLine(generator, ") {")
    increaseIndent(generator)
    if node.thenBranch.type == "BlockStatement" {
        generateBlockStatement(generator, node.thenBranch)
    } else {
        generateStatement(generator, node.thenBranch)
    }
    decreaseIndent(generator)
    if node.elseBranch {
        writeLine(generator, "} else {")
        increaseIndent(generator)
        if node.elseBranch.type == "BlockStatement" {
            generateBlockStatement(generator, node.elseBranch)
        } else {
            generateStatement(generator, node.elseBranch)
        }
        if node.elseBranch.type == "IfStatement" {
            decreaseIndent(generator)
            writeLine(generator, "}")
        } else {
            decreaseIndent(generator)
            writeLine(generator, "}")
        }
    } else {
        writeLine(generator, "}")
    }
    return generator
}

micro generateWhileStatement(generator, node) {
    write(generator, addIndent(generator) + "while (")
    generateExpression(generator, node.condition)
    writeLine(generator, ") {")
    increaseIndent(generator)
    if node.body.type == "BlockStatement" {
        generateBlockStatement(generator, node.body)
    } else {
        generateStatement(generator, node.body)
    }
    decreaseIndent(generator)
    writeLine(generator, "}")
    return generator
}

micro generateFunctionBody(generator, node) {
    let count = node.statements.length
    let i = 0
    while i < (count - 1) {
        generateStatement(generator, node.statements[i])
        i = i + 1
    }
    if count > 0 {
        let last = node.statements[count - 1]
        if last.type == "ExpressionStatement" {
            write(generator, addIndent(generator) + "return ")
            generateExpression(generator, last.expression)
            writeLine(generator, ";")
        } else if last.type == "IfStatement" {
            generateIfExpression(generator, last)
        } else if last.type == "ReturnStatement" {
            # 对于 ReturnStatement，直接生成内容，不重复生成 return 关键字
            write(generator, addIndent(generator) + "return")
            if last.value {
                write(generator, " ")
                generateExpression(generator, last.value)
            }
            writeLine(generator, ";")
        } else {
            generateStatement(generator, last)
        }
    }
    return generator
}

# 生成 If 表达式代码（用于函数体末尾）
micro generateIfExpression(generator, node) {
    write(generator, addIndent(generator) + "if (")
    generateExpression(generator, node.condition)
    writeLine(generator, ") {")
    increaseIndent(generator)
    if node.thenBranch.type == "BlockStatement" {
        generateFunctionBody(generator, node.thenBranch)
    } else {
        write(generator, addIndent(generator) + "return ")
        generateExpression(generator, node.thenBranch)
        writeLine(generator, ";")
    }
    decreaseIndent(generator)
    if node.elseBranch {
        writeLine(generator, "} else {")
        increaseIndent(generator)
        if node.elseBranch.type == "BlockStatement" {
            generateFunctionBody(generator, node.elseBranch)
        } else if node.elseBranch.type == "IfStatement" {
            generateIfExpression(generator, node.elseBranch)
        } else {
            write(generator, addIndent(generator) + "return ")
            generateExpression(generator, node.elseBranch)
            writeLine(generator, ";")
        }
        decreaseIndent(generator)
        writeLine(generator, "}")
    } else {
        writeLine(generator, "}")
    }
    return generator
}

# 生成代码块
micro generateBlockStatement(generator, node) {
    let i = 0
    while i < node.statements.length {
        generateStatement(generator, node.statements[i])
        i = i + 1
    }
    return generator
}

# 生成表达式语句代码
micro generateExpressionStatement(generator, node) {
    write(generator, addIndent(generator))
    generateExpression(generator, node.expression)
    writeLine(generator, ";")
    return generator
}

micro generateReturnStatement(generator, node) {
    write(generator, addIndent(generator) + "return")
    if node.value {
        write(generator, " ")
        generateExpression(generator, node.value)
    }
    writeLine(generator, ";")
    return generator
}

# 表达式分派
micro generateExpression(generator, node) {
    if node.type == "AssignmentExpression" {
        generateAssignmentExpression(generator, node)
    } else if node.type == "BinaryExpression" {
        generateBinaryExpression(generator, node)
    } else if node.type == "UnaryExpression" {
        generateUnaryExpression(generator, node)
    } else if node.type == "CallExpression" {
        generateCallExpression(generator, node)
    } else if node.type == "MemberExpression" {
        generateMemberExpression(generator, node)
    } else if node.type == "Identifier" {
        generateIdentifier(generator, node)
    } else if node.type == "NumberLiteral" {
        generateNumberLiteral(generator, node)
    } else if node.type == "StringLiteral" {
        generateStringLiteral(generator, node)
    } else if node.type == "BooleanLiteral" {
        generateBooleanLiteral(generator, node)
    } else if node.type == "ObjectLiteral" {
        generateObjectLiteral(generator, node)
    }
    return generator
}

# 生成导出语句代码
micro generateExportStatement(generator, node) {
    # export 声明形式（如 export let x = 1 或 export function f() {}）
    if node.declaration.type == "VariableDeclaration" {
        write(generator, addIndent(generator) + "export let " + node.declaration.name + " = ")
        generateExpression(generator, node.declaration.initializer)
        writeLine(generator, ";")
    } else if node.declaration.type == "FunctionDeclaration" {
        write(generator, addIndent(generator) + "export function " + node.declaration.name + "(")
        # 生成参数列表
        let i = 0
        while i < node.declaration.parameters.length {
            if i > 0 {
                write(generator, ", ")
            }
            write(generator, node.declaration.parameters[i].name)
            i = i + 1
        }
        writeLine(generator, ") {")
        increaseIndent(generator)
        generateStatement(generator, node.declaration.body)
        decreaseIndent(generator)
        writeLine(generator, "}")
    } else if node.specifiers.length > 0 {
        # export { ... } 形式
        write(generator, addIndent(generator) + "export { ")
        let i = 0
        while i < node.specifiers.length {
            if i > 0 {
                write(generator, ", ")
            }
            write(generator, node.specifiers[i])
            i = i + 1
        }
        writeLine(generator, " };")
    } else {
        # 空的导出语句，生成空的导出
        writeLine(generator, addIndent(generator) + "export {  };")
    }
    return generator
}

# 生成赋值表达式代码
micro generateAssignmentExpression(generator, node) {
    generateExpression(generator, node.left)
    write(generator, " = ")
    generateExpression(generator, node.right)
    return generator
}

# 运算符映射
let operatorMap = {
    PLUS = "+",
    MINUS = "-",
    MULTIPLY = "*",
    DIVIDE = "/",
    MODULO = "%",
    EQUAL = "==",
    NOT_EQUAL = "!=",
    LESS = "<",
    GREATER = ">",
    LESS_EQUAL = "<=",
    GREATER_EQUAL = ">=",
    AND = "&&",
    OR = "||",
    NOT = "!",
    ASSIGN = "="
}

micro getOperatorSymbol(operator) {
    if operatorMap[operator] {
        return operatorMap[operator]
    } else {
        return operator
    }
}

# 生成二元表达式代码
micro generateBinaryExpression(generator, node) {
    write(generator, "(")
    generateExpression(generator, node.left)
    let opSymbol = getOperatorSymbol(node.operator)
    write(generator, " " + opSymbol + " ")
    generateExpression(generator, node.right)
    write(generator, ")")
    return generator
}

# 生成一元表达式代码
micro generateUnaryExpression(generator, node) {
    let opSymbol = getOperatorSymbol(node.operator)
    write(generator, opSymbol)
    generateExpression(generator, node.operand)
    return generator
}

# 生成调用表达式代码
micro generateCallExpression(generator, node) {
    generateExpression(generator, node.callee)
    write(generator, "(")
    let i = 0
    while i < node.arguments.length {
        if i > 0 {
            write(generator, ", ")
        }
        generateExpression(generator, node.arguments[i])
        i = i + 1
    }
    write(generator, ")")
    return generator
}

# 生成成员表达式代码
micro generateMemberExpression(generator, node) {
    generateExpression(generator, node.object)
    if node.computed {
        write(generator, "[")
        generateExpression(generator, node.property)
        write(generator, "]")
    } else {
        write(generator, ".")
        generateExpression(generator, node.property)
    }
    return generator
}

# 生成数组字面量
micro generateArrayLiteral(generator, node) {
    write(generator, "[")
    let i = 0
    while i < node.elements.length {
        if i > 0 {
            write(generator, ", ")
        }
        generateExpression(generator, node.elements[i])
        i = i + 1
    }
    write(generator, "]")
    return generator
}

# 生成标识符
micro generateIdentifier(generator, node) {
    write(generator, node.name)
    return generator
}

# 生成数字字面量
micro generateNumberLiteral(generator, node) {
    write(generator, node.value)
    return generator
}

# 生成字符串字面量
micro generateStringLiteral(generator, node) {
    if node.value == "\n" {
        write(generator, "\"\\n\"")
    } else if node.value == "\\" {
        write(generator, "\"\\\\\"")
    } else if node.value == "\"" {
        write(generator, "\"\\\"\"")
    } else {
        # 对于普通字符串，需要转义特殊字符
        let value = node.value
        # 先转义反斜杠
        let i = 0
        let result = ""
        while i < value.length {
            let char = value[i]
            if char == "\\" {
                result = result + "\\\\"
            } else if char == "\"" {
                result = result + "\\\""
            } else if char == "\n" {
                result = result + "\\n"
            } else if char == "\t" {
                result = result + "\\t"
            } else if char == "\r" {
                result = result + "\\r"
            } else {
                result = result + char
            }
            i = i + 1
        }
        write(generator, "\"" + result + "\"")
    }
    return generator
}

# 生成布尔字面量代码
micro generateBooleanLiteral(generator, node) {
    if node.value {
        write(generator, "true")
    } else {
        write(generator, "false")
    }
    return generator
}

# 生成对象字面量代码
micro generateObjectLiteral(generator, node) {
    write(generator, "{")
    
    let i = 0
    while i < node.properties.length {
        if i > 0 {
            write(generator, ", ")
        }
        
        # 生成属性键值对
        let property = node.properties[i]
        write(generator, "\"" + property.key + "\"")
        write(generator, ": ")
        generateExpression(generator, property.value)
        
        i = i + 1
    }
    
    write(generator, "}")
    return generator
}

# 代码生成主函数
micro generate(ast) {
    let generator = initCodeGenerator()
    generateProgram(generator, ast)
    generator.output
}

# 导出函数
export {generate}