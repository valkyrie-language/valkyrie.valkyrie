# Valkyrie 语法分析器
# 使用 Valkyrie 语言实现

micro createProgram(statements, line, column) {
    let node = {}
    node.type = "Program"
    node.statements = statements
    node.line = line
    node.column = column
    node
}

micro createVariableDeclaration(name, value, mutable, typeAnnotation, line, column) {
    let node = {}
    node.type = "VariableDeclaration"
    node.name = name
    node.value = value
    node.mutable = mutable
    node.typeAnnotation = typeAnnotation
    node.line = line
    node.column = column
    node
}

micro createFunctionDeclaration(name, parameters, body, returnType, line, column) {
    let node = {}
    node.type = "FunctionDeclaration"
    node.name = name
    node.parameters = parameters
    node.body = body
    node.returnType = returnType
    node.line = line
    node.column = column
    node
}

micro createIfStatement(condition, thenBranch, elseBranch, line, column) {
    let node = {}
    node.type = "IfStatement"
    node.condition = condition
    node.thenBranch = thenBranch
    node.elseBranch = elseBranch
    node.line = line
    node.column = column
    node
}

micro createWhileStatement(condition, body, line, column) {
    let node = {}
    node.type = "WhileStatement"
    node.condition = condition
    node.body = body
    node.line = line
    node.column = column
    node
}

micro createExportStatement(declaration, specifiers, line, column) {
    let node = {}
    node.type = "ExportStatement"
    node.declaration = declaration
    node.specifiers = specifiers
    node.line = line
    node.column = column
    node
}

micro createIfExpression(condition, thenExpr, elseExpr, line, column) {
    let node = {}
    node.type = "IfExpression"
    node.condition = condition
    node.thenExpr = thenExpr
    node.elseExpr = elseExpr
    node.line = line
    node.column = column
    node
}

micro createBlockStatement(statements, line, column) {
    let node = {}
    node.type = "BlockStatement"
    node.statements = statements
    node.line = line
    node.column = column
    node
}

micro createExpressionStatement(expression, line, column) {
    let node = {}
    node.type = "ExpressionStatement"
    node.expression = expression
    node.line = line
    node.column = column
    node
}

micro createAssignmentExpression(left, right, line, column) {
    let node = {}
    node.type = "AssignmentExpression"
    node.left = left
    node.right = right
    node.line = line
    node.column = column
    node
}

micro createBinaryExpression(left, operator, right, line, column) {
    let node = {}
    node.type = "BinaryExpression"
    node.left = left
    node.operator = operator
    node.right = right
    node.line = line
    node.column = column
    node
}

micro createUnaryExpression(operator, operand, line, column) {
    let node = {}
    node.type = "UnaryExpression"
    node.operator = operator
    node.operand = operand
    node.line = line
    node.column = column
    node
}

micro createCallExpression(callee, args, line, column) {
    let node = {}
    node.type = "CallExpression"
    node.callee = callee
    node.arguments = args
    node.line = line
    node.column = column
    node
}

micro createIdentifier(name, line, column) {
    let node = {}
    node.type = "Identifier"
    node.name = name
    node.line = line
    node.column = column
    node
}

micro createNumberLiteral(value, line, column) {
    let node = {}
    node.type = "NumberLiteral"
    node.value = value
    node.line = line
    node.column = column
    node
}

micro createStringLiteral(value, line, column) {
    let node = {}
    node.type = "StringLiteral"
    node.value = value
    node.line = line
    node.column = column
    node
}

micro createBooleanLiteral(value, line, column) {
    let node = {}
    node.type = "BooleanLiteral"
    node.value = value
    node.line = line
    node.column = column
    node
}

micro createParameter(name, line, column) {
    let node = {}
    node.type = "Parameter"
    node.name = name
    node.line = line
    node.column = column
    node
}

micro createObjectLiteral(properties, line, column) {
    let node = {}
    node.type = "ObjectLiteral"
    node.properties = properties
    node.line = line
    node.column = column
    node
}

micro createArrayLiteral(elements, line, column) {
    let node = {}
    node.type = "ArrayLiteral"
    node.elements = elements
    node.line = line
    node.column = column
    node
}

micro createMemberExpression(object, property, computed, line, column) {
    let node = {}
    node.type = "MemberExpression"
    node.object = object
    node.property = property
    node.computed = computed
    node.line = line
    node.column = column
    node
}

micro createReturnStatement(value, line, column) {
    let node = {}
    node.type = "ReturnStatement"
    node.value = value
    node.line = line
    node.column = column
    node
}

micro parseExportStatement(parser) {
    let line = currentToken(parser).line
    let column = currentToken(parser).column
    expect(parser, "EXPORT")
    
    let declaration = null;
    let specifiers = [];
    
    if currentToken(parser).type == "LBRACE" {
        expect(parser, "LBRACE")
        
        while !check(parser, "RBRACE") && !check(parser, "EOF") {
            let identifier = expect(parser, "IDENTIFIER")
            specifiers.push(createIdentifier(identifier.value, identifier.line, identifier.column))
            
            if check(parser, "COMMA") {
                expect(parser, "COMMA")
            }
        }
        
        expect(parser, "RBRACE")
    } else {
        # throw new Error("Unexpected token after export: " + currentToken(parser).type)
    }
    
    createExportStatement(declaration, specifiers, line, column)
}

micro initParser(tokens) {
    let parser = {}
    parser.tokens = tokens
    parser.current = 0
    parser
}

micro currentToken(parser) {
    if parser.current >= parser.tokens.length {
        parser.tokens[parser.tokens.length - 1]
    } else {
        parser.tokens[parser.current]
    }
}

micro peekToken(parser) {
    if parser.current + 1 >= parser.tokens.length {
        parser.tokens[parser.tokens.length - 1]
    } else {
        parser.tokens[parser.current + 1]
    }
}

micro advance(parser) {
    if parser.current < parser.tokens.length - 1 {
        parser.current = parser.current + 1
    }
    parser
}

micro check(parser, tokenType) {
    let token = currentToken(parser)
    token.type == tokenType
}

micro match(parser, tokenType) {
    if check(parser, tokenType) {
        let token = currentToken(parser)
        advance(parser)
        token
    } else {
        null
    }
}

micro expect(parser, tokenType) {
    let token = match(parser, tokenType)
    if token == null {
        let current = currentToken(parser)
        console.log("[DEBUG] Expected " + tokenType + " but got " + current.type + " at line " + current.line + ", value: " + current.value)
        # throw new Error("Expected " + tokenType + " but got " + current.type + " at line " + current.line)
    } else {
        token
    }
}

micro parseProgram(parser) {
    let statements = []
    while !check(parser, "EOF") {
        let stmt = parseStatement(parser)
        if stmt.type != "" {
            statements.push(stmt)
        }
    }
    createProgram(statements, 1, 1)
}

micro parseStatement(parser) {
    let token = currentToken(parser)
    if token.type == "COMMENT" {
        advance(parser)
        token.type = ""
    } else if token.type == "LET" {
        parseVariableDeclaration(parser)
    } else if token.type == "MICRO" {
        parseFunctionDeclaration(parser)
    } else if token.type == "FUNCTION" {
        parseFunctionDeclaration(parser)
    } else if token.type == "RETURN" {
        parseReturnStatement(parser)
    } else if token.type == "IF" {
        parseIfStatement(parser)
    } else if token.type == "WHILE" {
        parseWhileStatement(parser)
    } else if token.type == "EXPORT" {
        parseExportStatement(parser)
    } else if token.type == "LBRACE" {
        parseBlockStatement(parser)
    } else {
        parseExpressionStatement(parser)
    }
}

micro parseVariableDeclaration(parser) {
    let letToken = expect(parser, "LET")
    let nameToken = expect(parser, "IDENTIFIER")
    expect(parser, "ASSIGN")
    let initializer = parseLogicalOr(parser)
    if check(parser, "SEMICOLON") {
        advance(parser)
    }
    createVariableDeclaration(nameToken.value, initializer, 2, 1, letToken.line, letToken.column)
}

micro parseFunctionDeclaration(parser) {
    let functionToken = currentToken(parser)
    if functionToken.type == "MICRO" {
        expect(parser, "MICRO")
    } else if functionToken.type == "FUNCTION" {
        expect(parser, "FUNCTION")
    }
    let nameToken = expect(parser, "IDENTIFIER")
    expect(parser, "LPAREN")
    let parameters = []
    if !check(parser, "RPAREN") {
        let param = expect(parser, "IDENTIFIER")
        parameters.push(createParameter(param.value, param.line, param.column))
        while check(parser, "COMMA") {
            advance(parser)
            param = expect(parser, "IDENTIFIER")
            parameters.push(createParameter(param.value, param.line, param.column))
        }
    }
    expect(parser, "RPAREN")
    let body = parseBlockStatement(parser)
    createFunctionDeclaration(nameToken.value, parameters, body, functionToken.line, functionToken.column)
}

micro parseReturnStatement(parser) {
    let returnToken = expect(parser, "RETURN")
    let value = null
    if !check(parser, "SEMICOLON") && !check(parser, "EOF") && !check(parser, "RBRACE") {
        value = parseExpression(parser)
    }
    if check(parser, "SEMICOLON") {
        advance(parser)
    }
    createReturnStatement(value, returnToken.line, returnToken.column)
}

micro parseIfStatement(parser) {
    let ifToken = expect(parser, "IF")
    let condition = parseExpression(parser)
    let thenBranch = parseBlockStatement(parser)
    let elseBranch = {}
    if check(parser, "ELSE") {
        advance(parser)
        if check(parser, "IF") {
            elseBranch = parseIfStatement(parser)
        } else {
            elseBranch = parseBlockStatement(parser)
        }
    }
    createIfStatement(condition, thenBranch, elseBranch, ifToken.line, ifToken.column)
}

micro parseWhileStatement(parser) {
    let whileToken = expect(parser, "WHILE")
    let condition = parseExpression(parser)
    let body = parseBlockStatement(parser)
    createWhileStatement(condition, body, whileToken.line, whileToken.column)
}

micro parseBlockStatement(parser) {
    let lbraceToken = expect(parser, "LBRACE")
    let statements = []
    while !check(parser, "RBRACE") && !check(parser, "EOF") {
        let stmt = parseStatement(parser)
        if stmt.type != "" {
            statements.push(stmt)
        }
    }
    expect(parser, "RBRACE")
    createBlockStatement(statements, lbraceToken.line, lbraceToken.column)
}

micro extractExpressionFromBlock(blockStatement) {
    if blockStatement.statements.length == 0 {
        # throw new Error("Block statement cannot be empty in expression context")
    }

    let lastStatement = blockStatement.statements[blockStatement.statements.length - 1]
    if lastStatement.type == "ExpressionStatement" {
        lastStatement.expression
    } else {
        # throw new Error("Last statement in block must be an expression statement")
    }
}

micro parseExpressionStatement(parser) {
    let expr = parseExpression(parser)
    if check(parser, "SEMICOLON") {
        advance(parser)
    }
    createExpressionStatement(expr, expr.line, expr.column)
}

micro parseExpression(parser) {
    parseAssignment(parser)
}

micro parseAssignment(parser) {
    let expr = parseLogicalOr(parser)

    if check(parser, "ASSIGN") {
        let assignToken = advance(parser)
        let right = parseAssignment(parser)
        createAssignmentExpression(expr, right, assignToken.line, assignToken.column)
    } else {
        expr
    }
}

micro parseObjectValue(parser) {
    let currentTok = currentToken(parser)

    if currentTok.type == "STRING" {
        let value = createStringLiteral(currentTok.value, currentTok.line, currentTok.column)
        advance(parser)
        value
    } else if currentTok.type == "NUMBER" {
        let value = createNumberLiteral(currentTok.value, currentTok.line, currentTok.column)
        advance(parser)
        value
    } else if currentTok.type == "TRUE" {
        let value = createBooleanLiteral(true, currentTok.line, currentTok.column)
        advance(parser)
        value
    } else if currentTok.type == "FALSE" {
        let value = createBooleanLiteral(false, currentTok.line, currentTok.column)
        advance(parser)
        value
    } else if currentTok.type == "IDENTIFIER" {
        let value = createIdentifier(currentTok.value, currentTok.line, currentTok.column)
        advance(parser)
        value
    } else if currentTok.type == "LBRACKET" {
        parseArrayLiteral(parser)
    } else if currentTok.type == "LBRACE" {
        parseObjectLiteral(parser)
    } else {
        parseLogicalOr(parser)
    }
}

micro parseArrayLiteral(parser) {
    let lbracketToken = expect(parser, "LBRACKET")
    let elements = []

    if check(parser, "RBRACKET") {
        expect(parser, "RBRACKET")
        createArrayLiteral([], lbracketToken.line, lbracketToken.column)
    } else {
        while !check(parser, "RBRACKET") && !check(parser, "EOF") {
            let element = parseObjectValue(parser)
            elements.push(element)

            if check(parser, "COMMA") {
                advance(parser)
                if check(parser, "RBRACKET") {
                    break
                }
            } else if !check(parser, "RBRACKET") {
                # throw new Error("Expected ',' or ']' in array literal at line " + currentToken(parser).line)
            }
        }

        expect(parser, "RBRACKET")
        createArrayLiteral(elements, lbracketToken.line, lbracketToken.column)
    }
}

micro parseObjectLiteral(parser) {
    let lbraceToken = expect(parser, "LBRACE")
    let properties = []

    if check(parser, "RBRACE") {
        expect(parser, "RBRACE")
        createObjectLiteral([], lbraceToken.line, lbraceToken.column)
    } else {
        while !check(parser, "RBRACE") && !check(parser, "EOF") {
            while check(parser, "COMMENT") {
                advance(parser)
            }

            if check(parser, "RBRACE") {
                break
            }

            let keyToken = {};
            if check(parser, "IDENTIFIER") {
                keyToken = expect(parser, "IDENTIFIER")
            } else if check(parser, "STRING") {
                keyToken = expect(parser, "STRING")
            } else {
                # throw new Error("Expected identifier or string as object key at line " + currentToken(parser).line)
            }
            expect(parser, "ASSIGN")

            let value = parseObjectValue(parser)

            let property = {}
            property.key = keyToken.value;
            property.value = value

            properties.push(property)

            if check(parser, "COMMA") {
                advance(parser)
                if check(parser, "RBRACE") {
                    break
                }
            } else if !check(parser, "RBRACE") {
                # throw new Error("Expected ',' or '}' after object property at line " + currentToken(parser).line)
            }
        }

        expect(parser, "RBRACE")
        createObjectLiteral(properties, lbraceToken.line, lbraceToken.column)
    }
}

micro parseLogicalOr(parser) {
    let expr = parseLogicalAnd(parser)

    while check(parser, "OR") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseLogicalAnd(parser)
        let operatorSymbol = "||"
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }

    expr
}

micro parseLogicalAnd(parser) {
    let expr = parseEquality(parser)

    while check(parser, "AND") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseEquality(parser)
        let operatorSymbol = "&&"
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }

    expr
}

micro parseEquality(parser) {
    let expr = parseComparison(parser)
    while check(parser, "EQUAL") || check(parser, "NOT_EQUAL") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseComparison(parser)
        let operatorSymbol = if operator.type == "EQUAL" { "==" } else { "!=" }
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }
    expr
}

micro parseComparison(parser) {
    let expr = parseAddition(parser)

    while check(parser, "LESS") || check(parser, "LE") || check(parser, "GREATER") || check(parser, "GE") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseAddition(parser)
        let operatorSymbol = "";
        if operator.type == "LESS" {
            operatorSymbol = "<"
        } else if operator.type == "LE" {
            operatorSymbol = "<="
        } else if operator.type == "GREATER" {
            operatorSymbol = ">"
        } else if operator.type == "GE" {
            operatorSymbol = ">="
        }
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }

    expr
}

micro parseAddition(parser) {
    let expr = parseMultiplication(parser)

    while check(parser, "PLUS") || check(parser, "MINUS") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseMultiplication(parser)
        let operatorSymbol = if operator.type == "PLUS" { "+" } else { "-" }
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }

    expr
}

micro parseMultiplication(parser) {
    let expr = parseUnary(parser)

    while check(parser, "MULTIPLY") || check(parser, "DIVIDE") || check(parser, "MODULO") {
        let operator = currentToken(parser)
        advance(parser)
        let right = parseUnary(parser)
        let operatorSymbol = "";
        if operator.type == "MULTIPLY" {
            operatorSymbol = "*"
        } else if operator.type == "DIVIDE" {
            operatorSymbol = "/"
        } else if operator.type == "MODULO" {
            operatorSymbol = "%"
        }
        expr = createBinaryExpression(expr, operatorSymbol, right, operator.line, operator.column)
    }

    expr
}

micro parseUnary(parser) {
    if check(parser, "NOT") || check(parser, "MINUS") {
        let operator = currentToken(parser)
        advance(parser)
        let operand = parseUnary(parser)
        let operatorSymbol = if operator.type == "NOT" { "!" } else { "-" }
        createUnaryExpression(operatorSymbol, operand, operator.line, operator.column)
    } else {
        parseCall(parser)
    }
}

micro parseCall(parser) {
    let expr = parsePrimary(parser)
    while check(parser, "LPAREN") || check(parser, "DOT") || check(parser, "LBRACKET") {
        if check(parser, "DOT") {
            advance(parser)
            let property = expect(parser, "IDENTIFIER")
            expr = createMemberExpression(expr, createIdentifier(property.value, property.line, property.column), false, expr.line, expr.column)
        } else if check(parser, "LBRACKET") {
            advance(parser)
            let index = parseExpression(parser)
            expect(parser, "RBRACKET")
            expr = createMemberExpression(expr, index, true, expr.line, expr.column)
        } else {
            advance(parser)
            let args = []
            if !check(parser, "RPAREN") {
                args.push(parseExpression(parser))
                while check(parser, "COMMA") {
                    advance(parser)
                    args.push(parseExpression(parser))
                }
            }
            let rparenToken = expect(parser, "RPAREN")
            expr = createCallExpression(expr, args, expr.line, expr.column)
        }
    }
    expr
}

micro parsePrimary(parser) {
    let token = currentToken(parser)
    if token.type == "NUMBER" {
        advance(parser)
        createNumberLiteral(token.value, token.line, token.column)
    } else if token.type == "STRING" {
        advance(parser)
        createStringLiteral(token.value, token.line, token.column)
    } else if token.type == "TRUE" {
        advance(parser)
        createBooleanLiteral(true, token.line, token.column)
    } else if token.type == "FALSE" {
        advance(parser)
        createBooleanLiteral(false, token.line, token.column)
    } else if token.type == "IDENTIFIER" {
        advance(parser)
        createIdentifier(token.value, token.line, token.column)
    } else if token.type == "IF" {
        advance(parser)
        let condition = parseExpression(parser)
        let thenBlock = parseBlockStatement(parser)
        expect(parser, "ELSE")
        let elseBlock = parseBlockStatement(parser)

        let thenExpr = extractExpressionFromBlock(thenBlock)
        let elseExpr = extractExpressionFromBlock(elseBlock)

        createIfExpression(condition, thenExpr, elseExpr, token.line, token.column)
    } else if token.type == "LBRACE" {
        parseObjectLiteral(parser)
    } else if token.type == "LBRACKET" {
        parseArrayLiteral(parser)
    } else if token.type == "LPAREN" {
        advance(parser)
        let expr = parseExpression(parser)
        expect(parser, "RPAREN")
        expr
    } else {
        # throw new Error("Unexpected token " + token.type + " at line " + token.line)
    }
}

micro parse(tokens) {
    let parser = initParser(tokens)
    parseProgram(parser)
}

export {parse}