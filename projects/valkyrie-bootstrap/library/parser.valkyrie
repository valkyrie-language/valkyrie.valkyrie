# Valkyrie 语法分析器
# 使用 Valkyrie 语言实现

# 导入词法分析器和 AST 模块
# namepath package
# using lexer
# using ast

# 语法分析器类
let Parser = {
    tokens = [],
    current = 0
}

# 初始化语法分析器
micro initParser(tokens) {
    let parser = {}
    parser.tokens = tokens
    parser.current = 0
    parser
}

# 获取当前 token
micro currentToken(parser) {
    if parser.current >= parser.tokens.length { 
        parser.tokens[parser.tokens.length - 1] 
    } else { 
        parser.tokens[parser.current] 
    }
}

# 获取下一个 token
micro peekToken(parser) {
    if parser.current + 1 >= parser.tokens.length {
        parser.tokens[parser.tokens.length - 1]  # EOF token
    } else {
        parser.tokens[parser.current + 1]
    }
}

# 前进到下一个 token
micro advance(parser) {
    if parser.current < parser.tokens.length - 1 {
        parser.current = parser.current + 1
    }
    parser
}

# 检查当前 token 类型
micro check(parser, tokenType) {
    let token = currentToken(parser)
    token.type == tokenType
}

# 匹配并消费 token
micro match(parser, tokenType) {
    if check(parser, tokenType) {
        let token = currentToken(parser)
        advance(parser)
        token
    } else {
        {}  # 返回空对象表示匹配失败
    }
}

# 期望特定类型的 token
micro expect(parser, tokenType) {
    let token = match(parser, tokenType)
    if token == {} {
        # 错误处理：期望的 token 类型不匹配
        let current = currentToken(parser)
        # 这里应该抛出错误，但暂时返回空对象
        {}
    } else {
        token
    }
}

# 解析程序
micro parseProgram(parser) {
    let statements = []
    
    # 解析所有语句直到 EOF
    while !(check(parser, "EOF")) {
        let stmt = parseStatement(parser)
        if stmt.type != "" {
            statements.push(stmt)
        }
    }
    
    createProgram(statements, 1, 1)
}

# 解析语句
micro parseStatement(parser) {
    let token = currentToken(parser)
    
    if token.type == "LET" {
        parseVariableDeclaration(parser)
    } else if token.type == "MICRO" {
        parseFunctionDeclaration(parser)
    } else if token.type == "IF" {
        parseIfStatement(parser)
    } else if token.type == "LBRACE" {
        parseBlockStatement(parser)
    } else {
        parseExpressionStatement(parser)
    }
}

# 解析变量声明
micro parseVariableDeclaration(parser) {
    let letToken = expect(parser, "LET")
    let nameToken = expect(parser, "IDENTIFIER")
    
    expect(parser, "ASSIGN")
    let initializer = parseExpression(parser)
    
    createVariableDeclaration(nameToken.value, initializer, letToken.line, letToken.column)
}

# 解析函数声明
micro parseFunctionDeclaration(parser) {
    let microToken = expect(parser, "MICRO")
    let nameToken = expect(parser, "IDENTIFIER")
    
    expect(parser, "LPAREN")
    let parameters = []
    
    # 解析参数列表
    if !check(parser, "RPAREN") {
        let param = expect(parser, "IDENTIFIER")
        parameters.push(createParameter(param.value, param.line, param.column))
        
        while check(parser, "COMMA") {
            advance(parser)  # 消费逗号
            param = expect(parser, "IDENTIFIER")
            parameters.push(createParameter(param.value, param.line, param.column))
        }
    }
    
    expect(parser, "RPAREN")
    let body = parseBlockStatement(parser)
    
    createFunctionDeclaration(nameToken.value, parameters, body, microToken.line, microToken.column)
}

# 解析 If 语句
micro parseIfStatement(parser) {
    let ifToken = expect(parser, "IF")
    let condition = parseExpression(parser)
    let thenBranch = parseBlockStatement(parser)
    
    let elseBranch = {}
    if check(parser, "ELSE") {
        advance(parser)  # 消费 else
        if check(parser, "IF") {
            elseBranch = parseIfStatement(parser)  # else if
        } else {
            elseBranch = parseBlockStatement(parser)  # else block
        }
    }
    
    createIfStatement(condition, thenBranch, elseBranch, ifToken.line, ifToken.column)
}

# 解析块语句
micro parseBlockStatement(parser) {
    let lbraceToken = expect(parser, "LBRACE")
    let statements = []
    
    while (!(check(parser, "RBRACE"))) && (!(check(parser, "EOF"))) {
        let stmt = parseStatement(parser)
        if stmt.type != "" {
            statements.push(stmt)
        }
    }
    
    expect(parser, "RBRACE")
    createBlockStatement(statements, lbraceToken.line, lbraceToken.column)
}

# 解析表达式语句
micro parseExpressionStatement(parser) {
    let expr = parseExpression(parser)
    createExpressionStatement(expr, expr.line, expr.column)
}

# 解析表达式
micro parseExpression(parser) {
    parseAssignment(parser)
}

# 解析赋值表达式
micro parseAssignment(parser) {
    let expr = parseLogicalOr(parser)
    
    if check(parser, "ASSIGN") {
        let assignToken = advance(parser)
        let right = parseAssignment(parser)
        createAssignmentExpression(expr, right, assignToken.line, assignToken.column)
    } else {
        expr
    }
}

# 解析逻辑或表达式
micro parseLogicalOr(parser) {
    let expr = parseLogicalAnd(parser)
    
    while check(parser, "OR") {
        let operator = advance(parser)
        let right = parseLogicalAnd(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析逻辑与表达式
micro parseLogicalAnd(parser) {
    let expr = parseEquality(parser)
    
    while check(parser, "AND") {
        let operator = advance(parser)
        let right = parseEquality(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析相等性表达式
micro parseEquality(parser) {
    let expr = parseComparison(parser)
    
    while check(parser, "EQ") || check(parser, "NE") {
        let operator = advance(parser)
        let right = parseComparison(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析比较表达式
micro parseComparison(parser) {
    let expr = parseAddition(parser)
    
    while check(parser, "LT") || check(parser, "LE") || check(parser, "GT") || check(parser, "GE") {
        let operator = advance(parser)
        let right = parseAddition(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析加法表达式
micro parseAddition(parser) {
    let expr = parseMultiplication(parser)
    
    while check(parser, "PLUS") || check(parser, "MINUS") {
        let operator = advance(parser)
        let right = parseMultiplication(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析乘法表达式
micro parseMultiplication(parser) {
    let expr = parseUnary(parser)
    
    while check(parser, "MULTIPLY") || check(parser, "DIVIDE") || check(parser, "MODULO") {
        let operator = advance(parser)
        let right = parseUnary(parser)
        expr = createBinaryExpression(expr, operator.value, right, operator.line, operator.column)
    }
    
    expr
}

# 解析一元表达式
micro parseUnary(parser) {
    if check(parser, "NOT") || check(parser, "MINUS") {
        let operator = advance(parser)
        let operand = parseUnary(parser)
        createUnaryExpression(operator.value, operand, operator.line, operator.column)
    } else {
        parseCall(parser)
    }
}

# 解析函数调用表达式
micro parseCall(parser) {
    let expr = parsePrimary(parser)
    
    while check(parser, "LPAREN") {
        advance(parser)  # 消费左括号
        let args = []
        
        if !check(parser, "RPAREN") {
            args.push(parseExpression(parser))
            
            while check(parser, "COMMA") {
                advance(parser)  # 消费逗号
                args.push(parseExpression(parser))
            }
        }
        
        let rparenToken = expect(parser, "RPAREN")
        expr = createCallExpression(expr, args, expr.line, expr.column)
    }
    
    expr
}

# 解析基本表达式
micro parsePrimary(parser) {
    let token = currentToken(parser)
    
    if token.type == "NUMBER" {
        advance(parser)
        createNumberLiteral(token.value, token.line, token.column)
    } else if token.type == "STRING" {
        advance(parser)
        createStringLiteral(token.value, token.line, token.column)
    } else if token.type == "TRUE" {
        advance(parser)
        createBooleanLiteral(true, token.line, token.column)
    } else if token.type == "FALSE" {
        advance(parser)
        createBooleanLiteral(false, token.line, token.column)
    } else if token.type == "IDENTIFIER" {
        advance(parser)
        createIdentifier(token.value, token.line, token.column)
    } else if token.type == "LBRACE" {
        advance(parser)  # 消费左大括号
        
        let properties = []
        
        # 检查是否是空对象
        if check(parser, "RBRACE") {
            # 空对象，直接消费右大括号k
            expect(parser, "RBRACE")
            createObjectLiteral([], token.line, token.column)
        } else {
            # 解析对象属性
            while (!(check(parser, "RBRACE"))) && (!(check(parser, "EOF"))) {
                # 解析属性键
                let keyToken = expect(parser, "IDENTIFIER")
                
                # 期望等号
                expect(parser, "ASSIGN")
                
                # 解析属性值
                let value = parseExpression(parser)
                
                # 创建属性对象
                let property = {}
                property.key = keyToken.value
                property.value = value
                properties.push(property)
                
                # 检查是否有逗号
                if check(parser, "COMMA") {
                    advance(parser)
                } else if !(check(parser, "RBRACE")) {
                    # 如果不是逗号也不是右大括号，报错
                    let dummy = 0  # 占位语句，实际应该抛出错误
                }
            }
            
            expect(parser, "RBRACE")
            createObjectLiteral(properties, token.line, token.column)
        }
    } else if token.type == "LBRACKET" {
        advance(parser)  # 消费左方括号
        
        let elements = []
        
        # 检查是否是空数组
        if check(parser, "RBRACKET") {
            # 空数组，直接消费右方括号
            expect(parser, "RBRACKET")
            createArrayLiteral([], token.line, token.column)
        } else {
            # 解析数组元素
            while (!(check(parser, "RBRACKET"))) && (!(check(parser, "EOF"))) {
                # 解析元素值
                let element = parseExpression(parser)
                elements.push(element)
                
                # 检查是否有逗号
                if check(parser, "COMMA") {
                    advance(parser)
                } else {
                    # 没有逗号就退出循环
                    let dummy = 0  # 占位语句
                }
            }
            
            expect(parser, "RBRACKET")
            createArrayLiteral(elements, token.line, token.column)
        }
    } else if token.type == "LPAREN" {
        advance(parser)  # 消费左括号
        let expr = parseExpression(parser)
        expect(parser, "RPAREN")
        expr
    } else {
        # 错误：意外的 token
        {}
    }
}

# 解析函数，主入口
micro parse(tokens) {
    let parser = initParser(tokens)
    parseProgram(parser)
}