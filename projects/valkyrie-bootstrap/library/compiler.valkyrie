# Valkyrie ç¼–è¯‘å™¨æ ¸å¿ƒæ¨¡å—
# æä¾›è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€ä»£ç ç”Ÿæˆå’Œå¤šæ–‡ä»¶ç¼–è¯‘åŠŸèƒ½

# å¯¼å…¥å¿…è¦çš„æ¨¡å—
let lexerNS = import("./lexer.js").await;
let parserNS = import("./parser.js").await;
let codegenNS = import("./codegen.js").await;

# ç¼–è¯‘å™¨ä¸»å‡½æ•°
micro compile(compiler) {
    let lexer = lexerNS.initLexer(compiler.source);
    let tokens = lexerNS.tokenize(lexer);
    
    if tokens.length == 0 {
        if compiler.source == "" {
            return "";
        }
        return "Error: Lexical analysis failed";
    }
    
    let ast = parserNS.parse(tokens);
    if ast.type == "" || ast.type == "ParseError" {
        return "Error: Syntax analysis failed";
    }
    
    # å¦‚æœæ˜¯å¤šæ–‡ä»¶æ¨¡å¼ï¼Œä½¿ç”¨å‘½åç©ºé—´è§£æ
    if compiler.multiFile {
        let resolvedAst = resolveMultipleNamespaces(ast);
        return codegenNS.generate(resolvedAst);
    }
    
    return codegenNS.generate(ast);
}

# åˆ›å»ºç¼–è¯‘å™¨é”™è¯¯å¯¹è±¡
micro createError(message, line, column) {
    return {
        "type": "CompilerError",
        "message": message,
        "line": line,
        "column": column
    };
}

# æŠ¥å‘Šç¼–è¯‘å™¨é”™è¯¯
micro reportError(error) {
    console.log("Compiler Error: " + error.message + " at line " + error.line + ", column " + error.column);
}

# åˆ›å»ºç¼–è¯‘å™¨é€‰é¡¹
micro createCompilerOptions(outputFormat, optimize, debug) {
    return {
        "outputFormat": outputFormat || "js",
        "optimize": optimize || false,
        "debug": debug || false
    };
}

# ä½¿ç”¨é€‰é¡¹ç¼–è¯‘
micro compileWithOptions(compiler, options) {
    compiler.options = options;
    
    if options.debug {
        console.log("Debug mode enabled");
    }
    
    let result = compile(compiler);
    
    if options.optimize {
        # è¿™é‡Œå¯ä»¥æ·»åŠ ä¼˜åŒ–é€»è¾‘
        result = result;
    }
    
    return result;
}

# åˆ›å»ºç¼–è¯‘ç»Ÿè®¡ä¿¡æ¯
micro createStats() {
    return {
        "tokensCount": 0,
        "astNodesCount": 0,
        "compilationTime": 0,
        "outputSize": 0
    };
}

# è®¡ç®—ASTèŠ‚ç‚¹æ•°é‡
micro countASTNodes(node) {
    if node == null {
        return 0;
    }
    
    let count = 1;
    
    if node.statements != null {
        let i = 0;
        while i < node.statements.length {
            count = count + countASTNodes(node.statements[i]);
            i = i + 1;
        }
    }
    
    if node.body != null {
        count = count + countASTNodes(node.body);
    }
    
    if node.left != null {
        count = count + countASTNodes(node.left);
    }
    
    if node.right != null {
        count = count + countASTNodes(node.right);
    }
    
    if node.expression != null {
        count = count + countASTNodes(node.expression);
    }
    
    if node.condition != null {
        count = count + countASTNodes(node.condition);
    }
    
    if node.thenBranch != null {
        count = count + countASTNodes(node.thenBranch);
    }
    
    if node.elseBranch != null {
        count = count + countASTNodes(node.elseBranch);
    }
    
    return count;
}

# ä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯ç¼–è¯‘
micro compileWithStats(compiler, options) {
    let stats = createStats();
    let startTime = Date.now();
    
    let result = compileWithOptions(compiler, options);
    
    stats.compilationTime = Date.now() - startTime;
    stats.outputSize = result.length;
    
    return {
        "result": result,
        "stats": stats
    };
}

# ç®€åŒ–çš„ç¼–è¯‘æ¥å£
micro compileSource(source) {
    let compiler = { "source": source, "multiFile": false };
    return compile(compiler);
}

# å¸¦é€‰é¡¹çš„ç¼–è¯‘æ¥å£
micro compileSourceWithOptions(source, outputFormat, optimize, debug) {
    let compiler = { "source": source, "multiFile": false };
    let options = createCompilerOptions(outputFormat, optimize, debug);
    return compileWithOptions(compiler, options);
}

# è¯­æ³•éªŒè¯
micro validateSyntax(source) {
    let lexer = lexerNS.initLexer(source);
    let tokens = lexerNS.tokenize(lexer);
    
    if tokens.length == 0 {
        return {
            "valid": false,
            "error": "Lexical analysis failed"
        };
    }
    
    let ast = parserNS.parse(tokens);
    if ast.type == "" || ast.type == "ParseError" {
        return {
            "valid": false,
            "error": "Syntax analysis failed"
        };
    }
    
    return {
        "valid": true,
        "error": null
    };
}

# è·¯å¾„è¿æ¥å·¥å…·å‡½æ•°
micro joinPath(pathArray, separator) {
    if pathArray == null || pathArray.length == 0 {
        return "";
    }
    
    let result = pathArray[0];
    let i = 1;
    while i < pathArray.length {
        result = result + separator + pathArray[i];
        i = i + 1;
    }
    return result;
}

# åˆ›å»ºå‘½åç©ºé—´ç®¡ç†å™¨
micro createNamespaceManager() {
    return {
        "namespaces": {},
        "usings": {},
        "currentNamespace": "",
        "currentFile": "",
        "mode": "repl"
    };
}

# è®¾ç½®ç¼–è¯‘æ¨¡å¼
micro setCompileMode(manager, mode) {
    manager.mode = mode;
}

# æ£€æŸ¥æ˜¯å¦ä¸ºä¸»å‘½åç©ºé—´
micro isMainNamespace(namespacePath) {
    return namespacePath.endsWith("!");
}

# è·å–ä¸»å‘½åç©ºé—´åç§°
micro getMainNamespaceName(namespacePath) {
    if isMainNamespace(namespacePath) {
        return namespacePath.substring(0, namespacePath.length - 1);
    }
    return namespacePath;
}

# æ·»åŠ ç¬¦å·åˆ°å‘½åç©ºé—´
micro addSymbolToNamespace(manager, namespacePath, symbolName, symbolType, symbolData, filePath) {
    if manager.namespaces[namespacePath] == null {
        manager.namespaces[namespacePath] = {
            "symbols": {},
            "files": []
        };
    }
    
    let namespaceData = manager.namespaces[namespacePath];
    
    # æ·»åŠ ç¬¦å·
    namespaceData.symbols[symbolName] = {
        "type": symbolType,
        "data": symbolData,
        "filePath": filePath
    };
    
    # æ·»åŠ æ–‡ä»¶åˆ°å‘½åç©ºé—´ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    let fileExists = false;
    let i = 0;
    while i < namespaceData.files.length {
        if namespaceData.files[i] == filePath {
            fileExists = true;
            break;
        }
        i = i + 1;
    }
    
    if !fileExists {
        namespaceData.files.push(filePath);
    }
}

# æ·»åŠ usingå¯¼å…¥
micro addUsingImport(manager, usingPath, isGlobal) {
    if manager.usings[manager.currentFile] == null {
        manager.usings[manager.currentFile] = [];
    }
    
    let usingInfo = {
        "namespace": usingPath,
        "isGlobal": isGlobal
    };
    
    manager.usings[manager.currentFile].push(usingInfo);
}

# è§£æç¬¦å·
micro resolveSymbol(manager, symbolName, currentNamespace, currentFile) {
    # é¦–å…ˆåœ¨å½“å‰å‘½åç©ºé—´ä¸­æŸ¥æ‰¾
    let currentNamespaceData = manager.namespaces[currentNamespace];
    if currentNamespaceData != null && currentNamespaceData.symbols != null {
        let symbol = currentNamespaceData.symbols[symbolName];
        if symbol != null {
            return {
                "found": true,
                "symbol": symbol,
                "namespace": currentNamespace
            };
        }
    }
    
    # ç„¶ååœ¨usingå¯¼å…¥ä¸­æŸ¥æ‰¾
    let fileUsings = manager.usings[currentFile];
    if fileUsings != null {
        let i = 0;
        while i < fileUsings.length {
            let usingInfo = fileUsings[i];
            let usingNamespace = usingInfo["namespace"];
            
            let usingNamespaceData = manager.namespaces[usingNamespace];
            if usingNamespaceData != null && usingNamespaceData.symbols != null {
                let symbol = usingNamespaceData.symbols[symbolName];
                if symbol != null {
                    return {
                        "found": true,
                        "symbol": symbol,
                        "namespace": usingNamespace
                    };
                }
            }
            
            i = i + 1;
        }
    }
    
    # æœ€ååœ¨å…¨å±€å‘½åç©ºé—´ä¸­æŸ¥æ‰¾
    let globalNamespaceData = manager.namespaces[""];
    if globalNamespaceData != null && globalNamespaceData.symbols != null {
        let symbol = globalNamespaceData.symbols[symbolName];
        if symbol != null {
            return {
                "found": true,
                "symbol": symbol,
                "namespace": ""
            };
        }
    }
    
    return {
        "found": false,
        "symbol": null,
        "namespace": null
    };
}

# è·å–å®Œå…¨é™å®šåç§°
micro getFullyQualifiedName(manager, symbolName, namespacePath) {
    if namespacePath == "" {
        return symbolName;
    }
    
    let cleanNamespace = getMainNamespaceName(namespacePath);
    return cleanNamespace.replace("::", "_") + "_" + symbolName;
}

# ç¼–è¯‘æºä»£ç æ–‡æœ¬
micro compileSourceText(sourceText) {
    let lexer = lexerNS.initLexer(sourceText);
    let tokens = lexerNS.tokenize(lexer);
    
    if tokens.length == 0 {
        if sourceText == "" {
            return "";
        }
        return "Error: Lexical analysis failed";
    }
    
    let ast = parserNS.parse(tokens);
    if ast.type == "" || ast.type == "ParseError" {
        return "Error: Syntax analysis failed";
    }
    
    return codegenNS.generate(ast);
}

# è§£æå¤šä¸ªå‘½åç©ºé—´
micro resolveMultipleNamespaces(ast) {
    let manager = createNamespaceManager();
    
    # ç¬¬ä¸€éï¼šæ”¶é›†æ‰€æœ‰å‘½åç©ºé—´å’Œç¬¦å·
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            let namespacePath = joinPath(stmt.path, "::");
            if stmt.isMainNamespace {
                namespacePath = namespacePath + "!";
            }
            manager.currentNamespace = namespacePath;
            
        } else if stmt.type == "UsingStatement" {
            let usingPath = joinPath(stmt.path, "::");
            let isGlobal = isMainNamespace(usingPath);
            addUsingImport(manager, usingPath, isGlobal);
            
        } else if stmt.type == "MicroDeclaration" {
            addSymbolToNamespace(manager, manager.currentNamespace, stmt.name, "function", stmt, manager.currentFile);
            
        } else if stmt.type == "ClassDeclaration" {
            addSymbolToNamespace(manager, manager.currentNamespace, stmt.name, "class", stmt, manager.currentFile);
            
        } else if stmt.type == "LetStatement" {
            addSymbolToNamespace(manager, manager.currentNamespace, stmt.name, "variable", stmt, manager.currentFile);
        }
        
        i = i + 1;
    }
    
    # ç¬¬äºŒéï¼šè§£æç¬¦å·å¼•ç”¨å¹¶ç”Ÿæˆå”¯ä¸€åç§°
    let j = 0;
    while j < ast.statements.length {
        let stmt = ast.statements[j];
        
        if stmt.type == "MicroDeclaration" {
            stmt.uniqueName = getFullyQualifiedName(manager, stmt.name, manager.currentNamespace);
            
        } else if stmt.type == "ClassDeclaration" {
            stmt.uniqueName = getFullyQualifiedName(manager, stmt.name, manager.currentNamespace);
            
        } else if stmt.type == "LetStatement" {
            stmt.uniqueName = getFullyQualifiedName(manager, stmt.name, manager.currentNamespace);
        }
        
        j = j + 1;
    }
    
    return ast;
}

# ç¼–è¯‘æ–‡ä»¶
micro compileFile(filePath, outputPath) {
    # è¿™é‡Œå¯ä»¥æ·»åŠ æ–‡ä»¶è¯»å–å’Œå†™å…¥é€»è¾‘
    return "File compilation not implemented yet";
}

# éªŒè¯å‘½åç©ºé—´è§„åˆ™
micro validateNamespaceRules(ast, mode) {
    let hasNamespace = false;
    let hasMainNamespace = false;
    
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            hasNamespace = true;
            if stmt.isMainNamespace {
                hasMainNamespace = true;
            }
        }
        
        i = i + 1;
    }
    
    if mode == "standard" && !hasNamespace {
        return "Error: Standard mode requires at least one namespace declaration";
    }
    
    if mode == "standard" && !hasMainNamespace {
        return "Error: Standard mode requires exactly one main namespace (ending with !)";
    }
    
    return "OK";
}

# å¤šæ–‡ä»¶ç¼–è¯‘
micro compileFolderWithMode(fileContents, mode) {
    let manager = createNamespaceManager();
    setCompileMode(manager, mode);
    
    # åˆ†ç±»æ”¶é›†è¯­å¥
    let jsImportStatements = [];
    let variableStatements = [];
    let functionStatements = [];
    let classStatements = [];
    let executionStatements = [];
    
    # å¤„ç†æ‰€æœ‰æ–‡ä»¶
    let fileNames = Object.keys(fileContents);
    let i = 0;
    while i < fileNames.length {
        let fileName = fileNames[i];
        let content = fileContents[fileName];
        
        manager.currentFile = fileName;
        
        # è¯æ³•å’Œè¯­æ³•åˆ†æ
        let lexerInstance = lexerNS.initLexer(content);
        let tokens = lexerNS.tokenize(lexerInstance);
        
        if tokens.length == 0 {
            i = i + 1;
            continue;
        }
        
        let ast = parserNS.parse(tokens);
        if ast.type != "Program" {
            return "Error: Failed to parse " + fileName;
        }
        
        # éªŒè¯å‘½åç©ºé—´è§„åˆ™
        let validationResult = validateNamespaceRules(ast, mode);
        if validationResult != "OK" {
            return validationResult;
        }
        
        # å¤„ç†è¯­å¥
        let currentNamespace = "";
        let j = 0;
        while j < ast.statements.length {
            let stmt = ast.statements[j];
            
            if stmt.type == "NamespaceStatement" {
                currentNamespace = joinPath(stmt.path, "::");
                if stmt.isMainNamespace {
                    currentNamespace = currentNamespace + "!";
                    
                    # åœ¨standardæ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥é‡å¤çš„ä¸»å‘½åç©ºé—´
                    if mode == "standard" {
                        console.log("ğŸ” æ£€æŸ¥ä¸»å‘½åç©ºé—´: " + currentNamespace);
                        console.log("ğŸ“‹ å½“å‰ç®¡ç†å™¨ä¸­çš„å‘½åç©ºé—´: " + Object.keys(manager.namespaces).join(", "));
                        if manager.namespaces[currentNamespace] != null {
                            let cleanName = currentNamespace.substring(0, currentNamespace.length - 1);
                            console.log("âŒ å‘ç°é‡å¤çš„ä¸»å‘½åç©ºé—´: " + cleanName);
                            return "Error: Duplicate main namespace '" + cleanName + "' found. Each main namespace must have a unique name.";
                        } else {
                            console.log("âœ… ä¸»å‘½åç©ºé—´æ£€æŸ¥é€šè¿‡: " + currentNamespace);
                        }
                    }
                }
                manager.currentNamespace = currentNamespace;
                
                # ç¡®ä¿å‘½åç©ºé—´è¢«æ·»åŠ åˆ°ç®¡ç†å™¨ä¸­
                if manager.namespaces[currentNamespace] == null {
                    manager.namespaces[currentNamespace] = {
                        "symbols": {},
                        "files": []
                    };
                }
                
            } else if stmt.type == "UsingStatement" {
                let usingPath = joinPath(stmt.path, "::");
                let isGlobal = isMainNamespace(usingPath);
                addUsingImport(manager, usingPath, isGlobal);
                
            } else if stmt.type == "JSImportStatement" {
                jsImportStatements.push(stmt);
                
            } else if stmt.type == "LetStatement" {
                variableStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "variable", stmt, fileName);
                
            } else if stmt.type == "MicroDeclaration" {
                functionStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "function", stmt, fileName);
                
            } else if stmt.type == "ClassDeclaration" {
                classStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "class", stmt, fileName);
                
            } else {
                executionStatements.push(stmt);
            }
            
            j = j + 1;
        }
        
        i = i + 1;
    }
    
    # æ£€æŸ¥é‡å¤çš„ä¸»å‘½åç©ºé—´
    if mode == "standard" {
        let mainNamespaces = [];
        let namespaceNames = Object.keys(manager.namespaces);
        let nsIndex = 0;
        while nsIndex < namespaceNames.length {
            let nsName = namespaceNames[nsIndex];
            if isMainNamespace(nsName) {
                let cleanName = getMainNamespaceName(nsName);
                let duplicateIndex = 0;
                let isDuplicate = false;
                while duplicateIndex < mainNamespaces.length {
                    if mainNamespaces[duplicateIndex] == cleanName {
                        isDuplicate = true;
                        break;
                    }
                    duplicateIndex = duplicateIndex + 1;
                }
                if isDuplicate {
                    return "Error: Duplicate main namespace '" + cleanName + "' found";
                }
                mainNamespaces.push(cleanName);
            }
            nsIndex = nsIndex + 1;
        }
    }
    
    # ç”Ÿæˆå”¯ä¸€åç§°
    let k = 0;
    while k < functionStatements.length {
        let funcStmt = functionStatements[k];
        funcStmt.uniqueName = getFullyQualifiedName(manager, funcStmt.name, funcStmt["namespace"] || "");
        k = k + 1;
    }
    
    let l = 0;
    while l < classStatements.length {
        let classStmt = classStatements[l];
        classStmt.uniqueName = getFullyQualifiedName(manager, classStmt.name, classStmt["namespace"] || "");
        l = l + 1;
    }
    
    let m = 0;
    while m < variableStatements.length {
        let varStmt = variableStatements[m];
        varStmt.uniqueName = getFullyQualifiedName(manager, varStmt.name, varStmt["namespace"] || "");
        m = m + 1;
    }
    
    # åˆå¹¶æ‰€æœ‰è¯­å¥
    let integratedAst = {
        "type": "Program",
        "statements": []
    };
    
    # æ·»åŠ JSå¯¼å…¥
    let n = 0;
    while n < jsImportStatements.length {
        integratedAst.statements.push(jsImportStatements[n]);
        n = n + 1;
    }
    
    # æ·»åŠ å˜é‡
    let o = 0;
    while o < variableStatements.length {
        integratedAst.statements.push(variableStatements[o]);
        o = o + 1;
    }
    
    # æ·»åŠ å‡½æ•°
    let p = 0;
    while p < functionStatements.length {
        integratedAst.statements.push(functionStatements[p]);
        p = p + 1;
    }
    
    # æ·»åŠ ç±»
    let q = 0;
    while q < classStatements.length {
        integratedAst.statements.push(classStatements[q]);
        q = q + 1;
    }
    
    # æ·»åŠ æ‰§è¡Œè¯­å¥
    let r = 0;
    while r < executionStatements.length {
        integratedAst.statements.push(executionStatements[r]);
        r = r + 1;
    }
    
    return codegenNS.generate(integratedAst);
}

# ç®€åŒ–çš„å¤šæ–‡ä»¶ç¼–è¯‘æ¥å£
micro compileFolder(fileContents) {
    return compileFolderWithMode(fileContents, "repl");
}

# è§£æå¤šä¸ªå‘½åç©ºé—´å¹¶ç”Ÿæˆä»£ç 
micro resolveMultipleNamespacesAndGenerate(ast) {
    let manager = createNamespaceManager();
    
    # åˆ†ç±»æ”¶é›†è¯­å¥
    let jsImportStatements = [];
    let variableStatements = [];
    let functionStatements = [];
    let classStatements = [];
    let executionStatements = [];
    
    let currentNamespace = "";
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            currentNamespace = joinPath(stmt.path, "::");
            if stmt.isMainNamespace {
                currentNamespace = currentNamespace + "!";
            }
            manager.currentNamespace = currentNamespace;
            
        } else if stmt.type == "UsingStatement" {
            let usingPath = joinPath(stmt.path, "::");
            let isGlobal = isMainNamespace(usingPath);
            addUsingImport(manager, usingPath, isGlobal);
            
        } else if stmt.type == "JSImportStatement" {
            jsImportStatements.push(stmt);
            
        } else if stmt.type == "LetStatement" {
            variableStatements.push(stmt);
            addSymbolToNamespace(manager, currentNamespace, stmt.name, "variable", stmt, manager.currentFile);
            
        } else if stmt.type == "MicroDeclaration" {
            functionStatements.push(stmt);
            addSymbolToNamespace(manager, currentNamespace, stmt.name, "function", stmt, manager.currentFile);
            
        } else if stmt.type == "ClassDeclaration" {
            classStatements.push(stmt);
            addSymbolToNamespace(manager, currentNamespace, stmt.name, "class", stmt, manager.currentFile);
            
        } else {
            executionStatements.push(stmt);
        }
        
        i = i + 1;
    }
    
    # ç”Ÿæˆå”¯ä¸€åç§°
    let j = 0;
    while j < functionStatements.length {
        let funcStmt = functionStatements[j];
        funcStmt.uniqueName = getFullyQualifiedName(manager, funcStmt.name, currentNamespace);
        j = j + 1;
    }
    
    let k = 0;
    while k < classStatements.length {
        let classStmt = classStatements[k];
        classStmt.uniqueName = getFullyQualifiedName(manager, classStmt.name, currentNamespace);
        k = k + 1;
    }
    
    let l = 0;
    while l < variableStatements.length {
        let varStmt = variableStatements[l];
        varStmt.uniqueName = getFullyQualifiedName(manager, varStmt.name, currentNamespace);
        l = l + 1;
    }
    
    # åˆå¹¶æ‰€æœ‰è¯­å¥
    let integratedAst = {
        "type": "Program",
        "statements": []
    };
    
    # æ·»åŠ JSå¯¼å…¥
    let m = 0;
    while m < jsImportStatements.length {
        integratedAst.statements.push(jsImportStatements[m]);
        m = m + 1;
    }
    
    # æ·»åŠ å˜é‡
    let n = 0;
    while n < variableStatements.length {
        integratedAst.statements.push(variableStatements[n]);
        n = n + 1;
    }
    
    # æ·»åŠ å‡½æ•°
    let o = 0;
    while o < functionStatements.length {
        integratedAst.statements.push(functionStatements[o]);
        o = o + 1;
    }
    
    # æ·»åŠ ç±»
    let p = 0;
    while p < classStatements.length {
        integratedAst.statements.push(classStatements[p]);
        p = p + 1;
    }
    
    # æ·»åŠ æ‰§è¡Œè¯­å¥
    let q = 0;
    while q < executionStatements.length {
        integratedAst.statements.push(executionStatements[q]);
        q = q + 1;
    }
    
    return codegenNS.generate(integratedAst);
}

# ç”Ÿæˆç®€å•å—è¯­å¥
micro generateSimpleBlock(blockStmt) {
    return "{\n  // Block statement placeholder\n  return null;\n}";
}

# å•æ–‡ä»¶ç¼–è¯‘å™¨ - è§£å†³è·¨æ¨¡å—è°ƒç”¨é—®é¢˜çš„å®Œæ•´è§£å†³æ–¹æ¡ˆ
micro compileSingleFileWithImports(sourceText) {
    let lexerInstance = lexerNS.initLexer(sourceText);
    let tokens = lexerNS.tokenize(lexerInstance);
    
    if tokens.length == 0 {
        if sourceText == "" {
            return "";
        }
        return "Error: Lexical analysis failed";
    }
    
    let ast = parserNS.parse(tokens);
    if ast.type == "" || ast.type == "ParseError" {
        return "Error: Syntax analysis failed";
    }
    
    let resolvedAst = resolveMultipleNamespacesAndGenerate(ast);
    return resolvedAst;
}

# åŸºäº compileFolderWithMode çš„å•æ–‡ä»¶ç¼–è¯‘å™¨
micro compileSingleFileComplete(sourceText) {
    let lexerInstance = lexerNS.initLexer(sourceText);
    let tokens = lexerNS.tokenize(lexerInstance);
    
    if tokens.length == 0 {
        if sourceText == "" {
            return "";
        }
        return "Error: Lexical analysis failed";
    }
    
    let ast = parserNS.parse(tokens);
    if ast.type == "" || ast.type == "ParseError" {
        return "Error: Syntax analysis failed";
    }
    
    let manager = createNamespaceManager();
    setCompileMode(manager, "repl");
    
    let jsImportStatements = [];
    let variableStatements = [];
    let functionStatements = [];
    let classStatements = [];
    let executionStatements = [];
    
    let currentNamespace = "";
    let i = 0;
    while i < ast.statements.length {
        let stmt = ast.statements[i];
        
        if stmt.type == "NamespaceStatement" {
            currentNamespace = joinPath(stmt.path, "::");
            if stmt.isMainNamespace {
                currentNamespace = currentNamespace + "!";
            }
            manager.currentNamespace = currentNamespace;
            manager.currentFile = "single_file";
            
        } else if stmt.type == "UsingStatement" {
            let usingPath = joinPath(stmt.path, "::");
            let isGlobal = isMainNamespace(usingPath);
            addUsingImport(manager, usingPath, isGlobal);
            
        } else if stmt.type == "JSImportStatement" {
            jsImportStatements.push(stmt);
            
        } else if stmt.type == "LetStatement" {
            variableStatements.push(stmt);
            
        } else if stmt.type == "MicroDeclaration" {
            functionStatements.push(stmt);
            
        } else if stmt.type == "ClassDeclaration" {
            classStatements.push(stmt);
            
        } else {
            executionStatements.push(stmt);
        }
        
        i = i + 1;
    }
    
    let uniqueNames = {};
    
    let j = 0;
    while j < functionStatements.length {
        let funcStmt = functionStatements[j];
        let uniqueName = getFullyQualifiedName(manager, funcStmt.name, currentNamespace);
        uniqueNames[funcStmt.name] = uniqueName;
        funcStmt.uniqueName = uniqueName;
        j = j + 1;
    }
    
    let k = 0;
    while k < classStatements.length {
        let classStmt = classStatements[k];
        let uniqueName = getFullyQualifiedName(manager, classStmt.name, currentNamespace);
        uniqueNames[classStmt.name] = uniqueName;
        classStmt.uniqueName = uniqueName;
        k = k + 1;
    }
    
    let l = 0;
    while l < variableStatements.length {
        let varStmt = variableStatements[l];
        let uniqueName = getFullyQualifiedName(manager, varStmt.name, currentNamespace);
        uniqueNames[varStmt.name] = uniqueName;
        varStmt.uniqueName = uniqueName;
        l = l + 1;
    }
    
    let integratedAst = {
        "type": "Program",
        "statements": []
    };
    
    let m = 0;
    while m < jsImportStatements.length {
        integratedAst.statements.push(jsImportStatements[m]);
        m = m + 1;
    }
    
    let n = 0;
    while n < variableStatements.length {
        integratedAst.statements.push(variableStatements[n]);
        n = n + 1;
    }
    
    let o = 0;
    while o < functionStatements.length {
        integratedAst.statements.push(functionStatements[o]);
        o = o + 1;
    }
    
    let p = 0;
    while p < classStatements.length {
        integratedAst.statements.push(classStatements[p]);
        p = p + 1;
    }
    
    let q = 0;
    while q < executionStatements.length {
        integratedAst.statements.push(executionStatements[q]);
        q = q + 1;
    }
    
    return codegenNS.generate(integratedAst);
}

# ç”Ÿæˆå•ä¸€JSæ–‡ä»¶çš„ä¸»å‡½æ•°
micro generateSingleJSFromAnalysis(fileContents, mode) {
    let manager = createNamespaceManager();
    setCompileMode(manager, mode || "repl");
    
    # åˆ†æä¾èµ–å…³ç³»
    let analyzer = createDependencyAnalyzer();
    
    # ç¬¬ä¸€éï¼šæ”¶é›†æ¯ä¸ªæ–‡ä»¶çš„usingä¾èµ–
    let fileNames = Object.keys(fileContents);
    let i = 0;
    while i < fileNames.length {
        let fileName = fileNames[i];
        let content = fileContents[fileName];
        
        analyzer.dependencies[fileName] = [];
        
        let lexerInstance = lexerNS.initLexer(content);
        let tokens = lexerNS.tokenize(lexerInstance);
        
        if tokens.length > 0 {
            let ast = parserNS.parse(tokens);
            
            if ast.type == "Program" {
                let j = 0;
                while j < ast.statements.length {
                    let stmt = ast.statements[j];
                    
                    if stmt.type == "UsingStatement" {
                        let usingPath = joinPath(stmt.path, "::");
                        let providerFile = findNamespaceProvider(usingPath, fileContents);
                        if providerFile != null && providerFile != fileName {
                            analyzer.dependencies[fileName].push(providerFile);
                        }
                    }
                    
                    j = j + 1;
                }
            }
        }
        
        i = i + 1;
    }
    
    # æ‹“æ‰‘æ’åº
    let sortResult = topologicalSort(analyzer, fileContents);
    if sortResult.error != null {
        return "Error: " + sortResult.error;
    }
    
    let sortedFiles = sortResult.sorted;
    
    # åˆ†ç±»æ”¶é›†è¯­å¥
    let jsImportStatements = [];
    let variableStatements = [];
    let functionStatements = [];
    let classStatements = [];
    let executionStatements = [];
    
    # æŒ‰ä¾èµ–é¡ºåºå¤„ç†æ–‡ä»¶
    let k = 0;
    while k < sortedFiles.length {
        let fileName = sortedFiles[k];
        let content = fileContents[fileName];
        
        manager.currentFile = fileName;
        
        let lexerInstance = lexerNS.initLexer(content);
        let tokens = lexerNS.tokenize(lexerInstance);
        
        if tokens.length == 0 {
            k = k + 1;
            continue;
        }
        
        let ast = parserNS.parse(tokens);
        if ast.type != "Program" {
            return "Error: Failed to parse " + fileName;
        }
        
        let validationResult = validateNamespaceRules(ast, mode);
        if validationResult != "OK" {
            return validationResult;
        }
        
        let currentNamespace = "";
        let l = 0;
        while l < ast.statements.length {
            let stmt = ast.statements[l];
            
            if stmt.type == "NamespaceStatement" {
                currentNamespace = joinPath(stmt.path, "::");
                if stmt.isMainNamespace {
                    currentNamespace = currentNamespace + "!";
                    
                    # åœ¨standardæ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥é‡å¤çš„ä¸»å‘½åç©ºé—´
                    if mode == "standard" {
                        console.log("ğŸ” æ£€æŸ¥ä¸»å‘½åç©ºé—´: " + currentNamespace);
                        console.log("ğŸ“‹ å½“å‰ç®¡ç†å™¨ä¸­çš„å‘½åç©ºé—´: " + Object.keys(manager.namespaces).join(", "));
                        if manager.namespaces[currentNamespace] != null {
                            let cleanName = currentNamespace.substring(0, currentNamespace.length - 1);
                            console.log("âŒ å‘ç°é‡å¤çš„ä¸»å‘½åç©ºé—´: " + cleanName);
                            return "Error: Duplicate main namespace '" + cleanName + "' found. Each main namespace must have a unique name.";
                        } else {
                            console.log("âœ… ä¸»å‘½åç©ºé—´æ£€æŸ¥é€šè¿‡: " + currentNamespace);
                        }
                    }
                }
                manager.currentNamespace = currentNamespace;
                
            } else if stmt.type == "UsingStatement" {
                let usingPath = joinPath(stmt.path, "::");
                let isGlobal = isMainNamespace(usingPath);
                addUsingImport(manager, usingPath, isGlobal);
                
            } else if stmt.type == "JSImportStatement" {
                jsImportStatements.push(stmt);
                
            } else if stmt.type == "LetStatement" {
                variableStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "variable", stmt, fileName);
                
            } else if stmt.type == "MicroDeclaration" {
                functionStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "function", stmt, fileName);
                
            } else if stmt.type == "ClassDeclaration" {
                classStatements.push(stmt);
                addSymbolToNamespace(manager, currentNamespace, stmt.name, "class", stmt, fileName);
                
            } else {
                executionStatements.push(stmt);
            }
            
            l = l + 1;
        }
        
        k = k + 1;
    }
    
    # æ£€æŸ¥é‡å¤ä¸»å‘½åç©ºé—´ï¼ˆä»…åœ¨standardæ¨¡å¼ä¸‹ï¼‰
    if mode == "standard" {
        let mainNamespaces = [];
        let mainNamespaceNames = [];
        
        # éå†æ‰€æœ‰å‘½åç©ºé—´ï¼Œæ”¶é›†ä¸»å‘½åç©ºé—´
        let namespaceKeys = Object.keys(manager.namespaces);
        let nsIndex = 0;
        while nsIndex < namespaceKeys.length {
            let nsName = namespaceKeys[nsIndex];
            if nsName.endsWith("!") {
                mainNamespaces.push(nsName);
                # æå–å¹²å‡€çš„å‘½åç©ºé—´åç§°ï¼ˆå»æ‰!ï¼‰
                let cleanName = nsName.substring(0, nsName.length - 1);
                mainNamespaceNames.push(cleanName);
            }
            nsIndex = nsIndex + 1;
        }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„ä¸»å‘½åç©ºé—´åç§°
        let duplicateIndex = 0;
        while duplicateIndex < mainNamespaceNames.length {
            let currentName = mainNamespaceNames[duplicateIndex];
            let checkIndex = duplicateIndex + 1;
            while checkIndex < mainNamespaceNames.length {
                if mainNamespaceNames[checkIndex] == currentName {
                    return "Error: Duplicate main namespace '" + currentName + "' found. Each main namespace must have a unique name.";
                }
                checkIndex = checkIndex + 1;
            }
            duplicateIndex = duplicateIndex + 1;
        }
    }
    
    # ç”Ÿæˆå”¯ä¸€åç§°
    let m = 0;
    while m < functionStatements.length {
        let funcStmt = functionStatements[m];
        funcStmt.uniqueName = getFullyQualifiedName(manager, funcStmt.name, funcStmt["namespace"] || "");
        m = m + 1;
    }
    
    let n = 0;
    while n < classStatements.length {
        let classStmt = classStatements[n];
        classStmt.uniqueName = getFullyQualifiedName(manager, classStmt.name, classStmt["namespace"] || "");
        n = n + 1;
    }
    
    let o = 0;
    while o < variableStatements.length {
        let varStmt = variableStatements[o];
        varStmt.uniqueName = getFullyQualifiedName(manager, varStmt.name, varStmt["namespace"] || "");
        o = o + 1;
    }
    
    # åˆå¹¶æ‰€æœ‰è¯­å¥
    let integratedAst = {
        "type": "Program",
        "statements": []
    };
    
    let p = 0;
    while p < jsImportStatements.length {
        integratedAst.statements.push(jsImportStatements[p]);
        p = p + 1;
    }
    
    let q = 0;
    while q < variableStatements.length {
        integratedAst.statements.push(variableStatements[q]);
        q = q + 1;
    }
    
    let r = 0;
    while r < functionStatements.length {
        integratedAst.statements.push(functionStatements[r]);
        r = r + 1;
    }
    
    let s = 0;
    while s < classStatements.length {
        integratedAst.statements.push(classStatements[s]);
        s = s + 1;
    }
    
    let t = 0;
    while t < executionStatements.length {
        integratedAst.statements.push(executionStatements[t]);
        t = t + 1;
    }
    
    return codegenNS.generate(integratedAst);
}

# REPLæ¨¡å¼çš„å•ä¸€JSæ–‡ä»¶ç”Ÿæˆ
micro generateSingleJS(fileContents) {
    return generateSingleJSFromAnalysis(fileContents, "repl");
}

# æ ‡å‡†æ¨¡å¼çš„å•ä¸€JSæ–‡ä»¶ç”Ÿæˆ
micro generateSingleJSStandard(fileContents) {
    return generateSingleJSFromAnalysis(fileContents, "standard");
}

# åˆ›å»ºä¾èµ–åˆ†æå™¨
micro createDependencyAnalyzer() {
    return {
        "dependencies": {},
        "reverseDependencies": {}
    };
}

# æŸ¥æ‰¾æä¾›æŒ‡å®šå‘½åç©ºé—´çš„æ–‡ä»¶
micro findNamespaceProvider(namespacePath, fileContents) {
    let fileNames = Object.keys(fileContents);
    let i = 0;
    while i < fileNames.length {
        let fileName = fileNames[i];
        let content = fileContents[fileName];
        
        let lexerInstance = lexerNS.initLexer(content);
        let tokens = lexerNS.tokenize(lexerInstance);
        
        if tokens.length > 0 {
            let ast = parserNS.parse(tokens);
            
            if ast.type == "Program" {
                let j = 0;
                while j < ast.statements.length {
                    let stmt = ast.statements[j];
                    
                    if stmt.type == "NamespaceStatement" {
                        let declaredNamespace = joinPath(stmt.path, "::");
                        if declaredNamespace == namespacePath {
                            return fileName;
                        }
                    }
                    
                    j = j + 1;
                }
            }
        }
        
        i = i + 1;
    }
    
    return null;
}

# æ‹“æ‰‘æ’åº (ç®€åŒ–ç‰ˆï¼Œä¸æ£€æµ‹å¾ªç¯ä¾èµ–)
micro topologicalSort(analyzer, fileContents) {
    let fileNames = Object.keys(fileContents);
    let visited = {};
    let sorted = [];
    
    let i = 0;
    while i < fileNames.length {
        visited[fileNames[i]] = false;
        i = i + 1;
    }
    
    let j = 0;
    while j < fileNames.length {
        let fileName = fileNames[j];
        if !visited[fileName] {
            simpleDfsVisit(fileName, analyzer, visited, sorted);
        }
        j = j + 1;
    }
    
    return {
        "error": null,
        "sorted": sorted
    };
}

# ç®€åŒ–çš„DFSè®¿é—® (ä¸æ£€æµ‹å¾ªç¯ä¾èµ–)
micro simpleDfsVisit(filePath, analyzer, visited, sorted) {
    if visited[filePath] {
        return;
    }
    
    visited[filePath] = true;
    
    let dependencies = analyzer.dependencies[filePath];
    if dependencies != null {
        let i = 0;
        while i < dependencies.length {
            let depFile = dependencies[i];
            simpleDfsVisit(depFile, analyzer, visited, sorted);
            i = i + 1;
        }
    }
    
    sorted.push(filePath);
}
