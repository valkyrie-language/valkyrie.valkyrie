namespace package::generation;

using package::ast::Node;
using package::generation::join_name_path;
using package::generation::SourceMapBuilder;
using package::generation::JsSourceMapping;
using package::generation::SourceSpan;

# JavaScript Code Generation Write Buffer with proper indentation management
class JsCodeGeneration {
    constructor(indent_text: String, options) {
        self.buffer = "";
        self.indent_level = 0;
        self.indent_text = indent_text;
        if indent_text == false {
            self.indent_text = "    ";
        }
        self.options = options;
        
        # Initialize source map support and JsSourceMapping as field
        if options && options.source_map {
            self.source_map_builder = new SourceMapBuilder();
            self.js_mapping = new JsSourceMapping(self.source_map_builder);
        } else {
            self.source_map_builder = false;
            self.js_mapping = false;
        }
        self.source_files = {};
    }
    
    micro indent(self) -> unit {
        self.indent_level = self.indent_level + 1;
    }
    
    micro dedent(self) -> unit {
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;
        }
    }
    
    micro write(self, text: String) -> unit {
        self.buffer = self.buffer + text;
        # Update source map position if enabled (不传递源映射信息，只更新位置)
        if self.js_mapping {
            # 更新位置但不添加映射，因为这里没有具体的源位置信息
            let i = 0;
            let newline_count = 0;
            while i < text.length {
                if text[i] == "\n" {
                    newline_count = newline_count + 1;
                }
                i = i + 1;
            }
            
            if newline_count > 0 {
                self.js_mapping.current_line = self.js_mapping.current_line + newline_count;
                self.js_mapping.current_column = 0;
            } else {
                self.js_mapping.current_column = self.js_mapping.current_column + text.length;
            }
        }
    }
    
    micro write_line(self, text: String) -> unit {
        let current_indent = "";
        let i = 0;
        while i < self.indent_level {
            current_indent = current_indent + self.indent_text;
            i = i + 1;
        }
        let full_line = current_indent + text + "\n";
        self.buffer = self.buffer + full_line;
        # Update source map position if enabled (不传递源映射信息，只更新位置)
        if self.js_mapping {
            # 更新位置但不添加映射，因为这里没有具体的源位置信息
            let i = 0;
            let newline_count = 0;
            while i < full_line.length {
                if full_line[i] == "\n" {
                    newline_count = newline_count + 1;
                }
                i = i + 1;
            }
            
            if newline_count > 0 {
                self.js_mapping.current_line = self.js_mapping.current_line + newline_count;
                self.js_mapping.current_column = 0;
            } else {
                self.js_mapping.current_column = self.js_mapping.current_column + full_line.length;
            }
        }
    }
    
    # Write with source mapping information
    micro write_with_mapping(self, text: String, source_span) -> unit {
        self.buffer = self.buffer + text;
        if self.js_mapping {
            if source_span {
                self.js_mapping.generate_with_mapping(text, source_span, 0);
            } else {
                self.js_mapping.generate_with_mapping(text, false, 0);
            }
        }
    }

    # 从 Node 创建 SourceSpan 的辅助函数
    micro create_source_span_from_node(self, node, file_name: String) {
        if node && node.has_valid_position() {
            let end_line = node.line;
            let end_column = node.column + node.length;
            return new SourceSpan(file_name, node.line, node.column, end_line, end_column);
        } else {
            return false;
        }
    }

    # 写入标识符并更新源映射
    micro write_identifier(self, identifier: String, source_span, source_index: u32) -> unit {
        if self.js_mapping && source_span && source_span.is_valid() {
            # 更新位置到当前缓冲区末尾
            self.js_mapping.update_position(self.js_mapping.current_line, self.js_mapping.current_column + self.buffer.length);
            # 为这个标识符添加源映射（委托给 SourceMapBuilder）
            self.js_mapping.source_map_builder.add_span_mapping(
                self.js_mapping.current_line,
                self.js_mapping.current_column,
                source_span,
                source_index
            );
            # 写入标识符
            self.buffer = self.buffer + identifier;
            # 更新位置
            self.js_mapping.current_column = self.js_mapping.current_column + identifier.length;
        } else {
            self.buffer = self.buffer + identifier;
        }
    }

    micro to_string(self) -> String {
        return self.buffer;
    }
    
    # Get the generated source map
    micro get_source_map(self) {
        if self.source_map_builder {
            return self.source_map_builder.build();
        }
        return false;
    }
    
    # 工具方法：字符串替换
    micro replace_all(self, str: String, search: String, replace: String) -> String {
        let result = "";
        let i = 0;
        while i < str.length {
            if str[i] == search {
                result = result + replace;
                i = i + search.length;
            } else {
                result = result + str[i];
                i = i + 1;
            }
        }
        return result;
    }
    
    # 生成 flags 声明
    micro generate_flags_declaration(self, node: Node) -> String {
        # 使用 unique_name 如果存在，否则使用 name
        let flagsName = node.unique_name || node.name;
        let members = node.members;
        
        let result = "const " + flagsName + " = {\n";
        
        # 生成成员
        let i = 0;
        while i < members.length {
            let member = members[i];
            if i > 0 {
                result = result + ",\n";
            }
            result = result + "  " + member.name + ": " + self.generate_expression(member.value);
            i = i + 1;
        }
        
        result = result + "\n};\n";
        
        # 添加冻结对象以防止修改
        result = result + "Object.freeze(" + flagsName + ");";
        
        return result;
    }
    
    # 生成 eidos 声明
    micro generate_eidos_declaration(self, node: Node) -> String {
        # 使用 unique_name 如果存在，否则使用 name
        let eidosName = node.unique_name;
        let members = node.members;
        
        let result = "const " + eidosName + " = {\n";
        
        # 生成成员
        let i = 0;
        while i < members.length {
            let member = members[i];
            if i > 0 {
                result = result + ",\n";
            }
            result = result + "  " + member.name + ": " + self.generate_expression(member.value);
            i = i + 1;
        }
        
        result = result + "\n};\n";
        
        # 添加冻结对象以防止修改
        result = result + "Object.freeze(" + eidosName + ");";
        
        return result;
    }
    

    
    # 生成表达式代码 - 主入口方法
    micro generate_expression(self, node: Node) -> String {
        match node.`type` {
            case "Number": 
                return self.generate_number_expression(node);
            case "String": 
                return self.generate_string_expression(node);
            case "Boolean": 
                return self.generate_boolean_expression(node);
            case "NamePath":
                return self.generate_namepath_expression(node);
            case "BinaryOp": 
                return self.generate_binary_op_expression(node);
            case "Assignment": 
                return self.generate_assignment_expression(node);
            case "TypeCheck": 
                return self.generate_type_check_expression(node);
            case "OptionalTypeCheck": 
                return self.generate_optional_type_check_expression(node);
            case "TypeCast": 
                return self.generate_type_cast_expression(node);
            case "OptionalTypeCast": 
                return self.generate_optional_type_cast_expression(node);
            case "MicroCall": 
                return self.generate_micro_call_expression(node);
            case "AnonymousFunction": 
                return self.generate_anonymous_function_expression(node);
            case "NewExpression": 
                return self.generate_new_expression(node);
            case "AwaitExpression": 
                return self.generate_await_expression(node);
            case "PropertyAccess": 
                return self.generate_property_access_expression(node);
            case "StaticMethodCall": 
                return self.generate_static_method_call_expression(node);
            case "StaticPropertyAccess": 
                return self.generate_static_property_access_expression(node);
            case "StaticMemberAccess": 
                return self.generate_static_member_access_expression(node);
            case "ArrayAccess": 
                return self.generate_array_access_expression(node);
            case "ObjectLiteral": 
                return self.generate_object_literal_expression(node);
            case "ArrayLiteral": 
                return self.generate_array_literal_expression(node);
            case "UnaryOp": 
                return self.generate_unary_op_expression(node);
            case "ThisExpression": 
                return self.generate_this_expression(node);
            case "DefaultValue": 
                return self.generate_default_value_expression(node);
            case "MatchExpression": 
                return self.generate_match_expression(node);
            else: 
                return "/* Unknown expression: " + node.`type` + " */";
        };
    }
    
    # 生成数字表达式
    micro generate_number_expression(self, node: Node) -> String {
        return node.value;
    }
    
    # 生成字符串表达式
    micro generate_string_expression(self, node: Node) -> String {
        # 处理字符串转义，确保与bootstrap/codegen.js一致，使用模块化函数
        let escaped = node.value;
        # 替换反斜杠
        escaped = self.replace_all(escaped, "\\", "\\\\");
        # 替换双引号
        escaped = self.replace_all(escaped, "\"", "\\\"");
        # 替换换行符
        escaped = self.replace_all(escaped, "\n", "\\n");
        # 替换回车符
        escaped = self.replace_all(escaped, "\r", "\\r");
        # 替换制表符
        escaped = self.replace_all(escaped, "\t", "\\t");
        return "\"" + escaped + "\"";
    }
    
    # 生成布尔表达式
    micro generate_boolean_expression(self, node: Node) -> String {
        return node.value;
    }
    
    # 生成标识符表达式
    micro generate_namepath_expression(self, node: Node) -> String {
        let name_index = 0;
        let identifier_name = "";
        while name_index < node.name_path.length {
            if name_index == 0 {
                identifier_name = node.unique_name || node.name_path[name_index].name;
            } else {
                identifier_name = identifier_name + "." + node.name_path[name_index].name;
            }
            name_index = name_index + 1;
        }
        return identifier_name;
    }
    
    # 生成二元操作表达式
    micro generate_binary_op_expression(self, node: Node) -> String {
        let left = self.generate_expression(node.left);
        let right = self.generate_expression(node.right);
        let result = "(";
        result = result + left;
        result = result + " ";
        result = result + node.operator;
        result = result + " ";
        result = result + right;
        result = result + ")";
        return result;
    }
    
    # 生成赋值表达式
    micro generate_assignment_expression(self, node: Node) -> String {
        let left = self.generate_expression(node.left);
        let right = self.generate_expression(node.right);
        return left + " = " + right;
    }
    
    # 生成类型检查表达式
    micro generate_type_check_expression(self, node: Node) -> String {
        let expr = self.generate_expression(node.expression);
        let pattern = self.generate_pattern_expression(node.pattern);
        # 生成 instanceof 检查或类型检查函数调用
        return "(" + expr + " instanceof " + pattern + ")";
    }
    
    # 生成可选类型检查表达式
    micro generate_optional_type_check_expression(self, node: Node) -> String {
        let expr = self.generate_expression(node.expression);
        let pattern = self.generate_pattern_expression(node.pattern);
        # 生成可选的类型检查，如果检查失败返回 false 而不是抛出异常
        return "(function() { try { return " + expr + " instanceof " + pattern + "; } catch(e) { return false; } })()";
    }
    
    # 生成类型转换表达式
    micro generate_type_cast_expression(self, node: Node) -> String {
        let expr = self.generate_expression(node.expression);
        let targetType = self.generate_type_expression(node.targetType);
        # 生成类型转换，这里简化处理，实际应该根据类型生成相应的转换代码
        return "(" + expr + ")";
    }
    
    # 生成可选类型转换表达式
    micro generate_optional_type_cast_expression(self, node: Node) -> String {
        let expr = self.generate_expression(node.expression);
        let targetType = self.generate_type_expression(node.targetType);
        # 生成可选的类型转换，如果转换失败返回 null 而不是抛出异常
        return "(function() { try { return (" + expr + "); } catch(e) { return null; } })()";
    }
    
    # 生成微函数调用表达式
    micro generate_micro_call_expression(self, node: Node) -> String {
        let callee = self.generate_expression(node.callee);
        let args = "";

        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + self.generate_expression(node.arguments[i]);
            i = i + 1;
        }

        # 检查是否有尾随闭包
        if node.closure {
            # 生成尾随闭包的 JavaScript 代码
            let closureParams = "";
            # 尾随闭包通常需要参数，根据函数签名推断
            # 对于forEach这样的函数，第一个参数是数组元素
            # 对于doSomething这样的函数，没有参数
            
            # 根据函数名推断参数
            let calleeStr = "";
            if node.callee && node.callee.name {
                calleeStr = node.callee.name;
            } else {
                calleeStr = callee;
            }
            
            if calleeStr == "forEach" {
                closureParams = "item";
            }

            let closureBody = "";
            if node.closure {
                # closure 是一个 Block 节点
                closureBody = self.generate_statement(node.closure);
            }

            # 如果有普通参数，添加逗号分隔
            if args.length > 0 {
                args = args + ", ";
            }
            args = args + "function(" + closureParams + ") " + closureBody;
        }

        return callee + "(" + args + ")";
    }
    
    # 生成匿名函数表达式
    micro generate_anonymous_function_expression(self, node: Node) -> String {
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            let param = node.parameters[i];
            if param {
                if param.name {
                    params = params + param.name;
                } else {
                    params = params + "param" + i;
                }
            } else {
                params = params + "param" + i;
            }
            i = i + 1;
        }

        let body = "";
        if node.body {
            body = self.generate_statement(node.body);
        }

        return "function(" + params + ") " + body;
    }
    
    # 生成 new 表达式
    micro generate_new_expression(self, node: Node) -> String {
        let args = "";

        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + self.generate_expression(node.arguments[i]);
            i = i + 1;
        }
        return "new " + node.className.unique_name + "(" + args + ")";
    }
    
    # 生成 await 表达式
    micro generate_await_expression(self, node: Node) -> String {
        let argument = self.generate_expression(node.argument);
        return "await " + argument;
    }
    
    # 生成属性访问表达式
    micro generate_property_access_expression(self, node: Node) -> String {
        if node.object.`type` {
            let obj = self.generate_expression(node.object);
            return obj + "." + node.property;
        } else {
            return node.object + "." + node.property;
        }
    }
    
    # 生成静态方法调用表达式
    micro generate_static_method_call_expression(self, node: Node) -> String {
        let className = "";
        if node.namespacePath {
            # 使用新的namespacePath支持多级命名空间
            if node.namespacePath.length >= 2 {
                className = node.namespacePath[node.namespacePath.length - 2];
            } else {
                className = node.namespacePath[0];
            }
        } else if node.className.`type` {
            className = self.generate_expression(node.className);
        } else {
            className = node.className;
        }

        let args = "";
        let i = 0;
        while i < node.arguments.length {
            if i > 0 {
                args = args + ", ";
            }
            args = args + self.generate_expression(node.arguments[i]);
            i = i + 1;
        }

        return className + "." + node.methodName + "(" + args + ")";
    }
    
    # 生成静态属性访问表达式
    micro generate_static_property_access_expression(self, node: Node) -> String {
        let className = "";
        if node.namespacePath {
            # 使用新的namespacePath支持多级命名空间
            if node.namespacePath.length >= 2 {
                className = node.namespacePath[node.namespacePath.length - 2];
            } else {
                className = node.namespacePath[0];
            }
        } else if node.className.`type` {
            className = self.generate_expression(node.className);
        } else {
            className = node.className;
        }

        return className + "." + node.property;
    }
    
    # 生成静态成员访问表达式 (用于 eidos/flags)
    micro generate_static_member_access_expression(self, node: Node) -> String {
        # 对于 eidos/flags 静态成员访问，需要正确处理命名空间
        let objectName = "";
        let memberName = node.member;
        
        # 检查是否有 namespacePath 信息，如果有则使用它来构建正确的名称
        if node.namespacePath && node.namespacePath.length > 0 {
            # 使用 namespacePath 中的最后一个元素作为类名
            # 这通常是正确的唯一名称
            objectName = node.namespacePath[node.namespacePath.length - 1];
        } else if node.object && node.object.name_path && node.object.name_path.length > 0 {
            # 处理 NamePath 类型的对象
            objectName = self.join_name_path(node.object.name_path, "_");
        } else if node.object && node.object.name {
            # 处理 Identifier 类型的对象
            objectName = node.object.name;
        } else if node.object && typeof(node.object) == "string" {
            # 处理字符串类型的对象
            objectName = node.object;
        } else {
            # 如果无法确定对象名称，使用默认值
            objectName = "UnknownObject";
        }

        # 检查是否是 eidos 类型（检查 node 是否有 is_eidos 属性）
        if node.is_eidos {
            # 对于 Eidos 枚举，我们需要返回枚举成员的实际值
            # 而不是枚举对象的属性访问
            # 例如：DiagnosticLevel::ERROR 应该返回 "ERROR" 而不是 DiagnosticLevel.ERROR
            return "\"" + memberName + "\"";
        }

        return objectName + "." + memberName;
    }
    
    # 生成数组访问表达式
    micro generate_array_access_expression(self, node: Node) -> String {
        let obj = "";
        if node.object.`type` {
            obj = self.generate_expression(node.object);
        } else {
            obj = node.object;
        }
        let index = self.generate_expression(node.index);
        return obj + "[" + index + "]";
    }
    
    # 生成对象字面量表达式
    micro generate_object_literal_expression(self, node: Node) -> String {
        if node.properties.length == 0 {
            return "{}";
        }
        let result = "{";
        let i = 0;
        while i < node.properties.length {
            let prop = node.properties[i];
            if i > 0 {
                result = result + ", ";
            }
            result = result + "\"" + prop.key + "\": " + self.generate_expression(prop.value);
            i = i + 1;
        }
        result = result + "}";
        return result;
    }
    
    # 生成数组字面量表达式
    micro generate_array_literal_expression(self, node: Node) -> String {
        return "[]";
    }
    
    # 生成一元操作表达式
    micro generate_unary_op_expression(self, node: Node) -> String {
        let operand = self.generate_expression(node.operand);
        return node.operator + operand;
    }
    
    # 生成 this 表达式
    micro generate_this_expression(self, node: Node) -> String {
        return "this";
    }
    
    # 生成默认值表达式
    micro generate_default_value_expression(self, node: Node) -> String {
        return "undefined";
    }
    
    # 生成语句代码 - 主入口方法
    micro generate_statement(self, node: Node) -> String {
        match node.`type` {
            case "LetStatement": 
                return self.generate_let_statement(node);
            case "NamespaceStatement": 
                return self.generate_namespace_statement(node);
            case "UsingStatement": 
                return self.generate_using_statement(node);
            case "JSAttributeStatement": 
                return self.generate_js_attribute_statement(node);
            case "ImportJsStatement": 
                return self.generate_import_js_statement(node);
            case "MicroDeclaration": 
                return self.generate_micro_declaration(node);
            case "MemberStatement": 
                return self.generate_member_statement(node);
            case "IfStatement": 
                return self.generate_if_statement(node);
            case "WhileStatement": 
                return self.generate_while_statement(node);
            case "UntilStatement": 
                return self.generate_until_statement(node);
            case "ReturnStatement": 
                return self.generate_return_statement(node);
            case "Block": 
                return self.generate_block_statement(node);
            case "ExpressionStatement": 
                return self.generate_expression_statement(node);
            case "ClassDeclaration": 
                return self.generate_class_declaration(node);
            case "TraitDeclaration": 
                return self.generate_trait_declaration(node);
            case "SingletonDeclaration": 
                return self.generate_singleton_declaration(node);
            case "FlagsDeclaration": 
                return self.generate_flags_declaration(node);
            case "EidosDeclaration": 
                return self.generate_eidos_declaration(node);
            else: 
                return "/* Unknown statement: " + node.`type` + " */";
        };
    }
    
    # 生成 let 语句
    micro generate_let_statement(self, node: Node) -> String {
        let value = self.generate_expression(node.value);
        return "let " + node.name + " = " + value + ";";
    }
    
    # 生成命名空间语句
    micro generate_namespace_statement(self, node: Node) -> String {
        # namespace 语句在单文件编译中被忽略，在多文件编译中用于符号管理
        let namespacePath = self.join_name_path(node.path, "_");
        if node.is_main_namespace {
            return "// namespace! " + namespacePath + ";";
        } else {
            return "// namespace " + namespacePath + ";";
        }
    }
    
    # 生成 using 语句
    micro generate_using_statement(self, node: Node) -> String {
        # using 语句在整合编译中被忽略，在多文件编译中用于符号导入
        return "// using " + join_name_path(node.path, "__") + ";";
    }
    
    # 生成 JS 属性语句
    micro generate_js_attribute_statement(self, node: Node) -> String {
        # 生成 JS 导入语句和函数定义
        let cleanImportName = self.replace_all(node.importName, "-", "_");
        cleanImportName = self.replace_all(cleanImportName, ".", "_");
        cleanImportName = self.replace_all(cleanImportName, "/", "_");
        let unique_name = node.functionName + "_" + cleanImportName;
        let importStatement = "import { " + node.importName + " as " + unique_name + " } from \"" + node.modulePath + "\";";

        # 生成函数包装
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            params = params + node.parameters[i];
            i = i + 1;
        }

        let functionDef = "export function " + node.functionName + "(" + params + ") {\n";
        functionDef = functionDef + "  return " + unique_name + "(" + params + ");\n";
        functionDef = functionDef + "}";

        return importStatement + "\n" + functionDef;
    }
    
    # 生成 JS 导入语句
    micro generate_import_js_statement(self, node: Node) -> String {
        # 生成 JS 导入语句：import {importName as localName} from "module"
        return "import { " + node.importName + " as " + node.localName + " } from \"" + node.module + "\";";
    }
    
    # 生成微函数声明
    micro generate_micro_declaration(self, node: Node) -> String {
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            # 处理新的 Parameter 节点结构
            let param = node.parameters[i];
            if param && param.name {
                params = params + param.name;
            } else {
                # 兼容旧的字符串格式
                params = params + param;
            }
            i = i + 1;
        }

        let body = self.generate_statement(node.body);
        # 直接使用 name 字段（已经是解析后的名称）
        let functionName = node.unique_name;
        return "export function " + functionName + "(" + params + ") " + body;
    }
    
    # 生成成员语句
    micro generate_member_statement(self, node: Node) -> String {
        let params = "";
        let i = 0;
        while i < node.parameters.length {
            if i > 0 {
                params = params + ", ";
            }
            # 处理新的 Parameter 节点结构
            let param = node.parameters[i];
            if param && param.name {
                params = params + param.name;
            } else {
                # 兼容旧的字符串格式
                params = params + param;
            }
            i = i + 1;
        }

        let body = self.generate_statement(node.body);
        return "function " + node.name + "(" + params + ") " + body;
    }
    
    # 生成 if 语句
    micro generate_if_statement(self, node: Node) -> String {
        let condition = self.generate_expression(node.condition);
        let thenBranch = self.generate_statement(node.thenBranch);
        let result = "if (" + condition + ") " + thenBranch;

        if node.elseBranch && node.elseBranch.`type` {
            let elseBranch = self.generate_statement(node.elseBranch);
            result = result + " else " + elseBranch;
        }

        return result;
    }
    
    # 生成 while 语句
    micro generate_while_statement(self, node: Node) -> String {
        let condition = self.generate_expression(node.condition);
        let body = self.generate_statement(node.body);
        return "while (" + condition + ") " + body;
    }
    
    # 生成 until 语句
    micro generate_until_statement(self, node: Node) -> String {
        let condition = self.generate_expression(node.condition);
        let body = self.generate_statement(node.body);
        return "while (!(" + condition + ")) " + body;
    }
    
    # 生成 return 语句
    micro generate_return_statement(self, node: Node) -> String {
        if node.value && node.value.`type` {
            let value = self.generate_expression(node.value);
            return "return " + value + ";";
        } else {
            return "return;";
        }
    }
    
    # 生成块语句
    micro generate_block_statement(self, node: Node) -> String {
        let statements = "";
        let i = 0;
        while i < node.statements.length {
            let stmt = self.generate_statement(node.statements[i]);
            if i > 0 {
                statements = statements + "\n";
            }
            statements = statements + stmt;
            i = i + 1;
        }
        return "{\n" + statements + "\n}";
    }
    
    # 生成表达式语句
    micro generate_expression_statement(self, node: Node) -> String {
        return self.generate_expression(node.expression) + ";";
    }
    
    # 生成类声明
    micro generate_class_declaration(self, node: Node) -> String {
        # 直接使用 name 字段（已经是解析后的名称）
        let className = node.unique_name;
        let superClasses = node.superClassesUniqueNames; # Use superClassesUniqueNames for mixins
        let members = node.members;

        let result = "class " + className + " {\n";

        # Removed inheritance via 'extends' keyword

        # 检查是否有显式构造函数
        let hasExplicitConstructor = false;
        let explicitConstructor = null;
        let fieldInits = "";
        let i = 0;
        while i < members.length {
            let member = members[i];
            if member.`type` == "ConstructorStatement" {
                hasExplicitConstructor = true;
                explicitConstructor = member;
            } else if member.`type` == "Property" {
                if member.initializer && member.initializer.`type` {
                    let initValue = self.generate_expression(member.initializer);
                    fieldInits = fieldInits + "    self." + member.name + " = " + initValue + ";\n";
                } else {
                    fieldInits = fieldInits + "    self." + member.name + " = undefined;\n";
                }
            }
            i = i + 1;
        }

        # 生成构造函数
        if hasExplicitConstructor {
            # 使用显式构造函数
            let params = "";
            let j = 0;
            while j < explicitConstructor.parameters.length {
                if j > 0 {
                    params = params + ", ";
                }
                # 处理新的 Parameter 节点结构
                let param = explicitConstructor.parameters[j];
                if param && param.name {
                    params = params + param.name;
                } else {
                    # 兼容旧的字符串格式
                    params = params + param;
                }
                j = j + 1;
            }
            result = result + "  constructor(" + params + ") {\n";
            # No super() call for mixins
            result = result + fieldInits;
            let ctorBody = self.generate_statement(explicitConstructor.body);
            # 移格外层的大括号，只保留内容
            if ctorBody.startsWith("{\n") && ctorBody.endsWith("\n}") {
                ctorBody = ctorBody.substring(2, ctorBody.length - 2);
            }
            result = result + ctorBody;
            result = result + "  }\n\n";
        } else if fieldInits != "" {
            # 自动生成构造函数用于字段初始化
            result = result + "  constructor() {\n";
            # No super() call for mixins
            result = result + fieldInits;
            result = result + "  }\n\n";
        }

        # 生成类方法
        i = 0;
        while i < members.length {
            let member = members[i];
            if member.`type` == "MemberStatement" {
                let methodName = member.name;
                let params = "";
                let j = 0;
                let paramCount = 0;
                while j < member.parameters.length {
                    # 跳过 self 参数，因为在 ES6 class 中不需要显式的 self
                    let param = member.parameters[j];
                    let paramName = "";

                    # 处理新的 Parameter 节点结构
                    if param && param.name {
                        paramName = param.name;
                    } else {
                        # 兼容旧的字符串格式
                        paramName = param;
                    }

                    if paramName != "self" {
                        if paramCount > 0 {
                            params = params + ", ";
                        }
                        params = params + paramName;
                        paramCount = paramCount + 1;
                    }
                    j = j + 1;
                }
                let body = self.generate_statement(member.body);
                # 根据是否为静态方法生成不同的代码
                # 修复：检查isInstanceMethod而不是isStatic，因为有self参数的是实例方法
                if member.isInstanceMethod {
                    result = result + "  " + methodName + "(" + params + ") " + body + "\n\n";
                } else {
                    result = result + "  static " + methodName + "(" + params + ") " + body + "\n\n";
                }
            }
            i = i + 1;
        }

        result = result + "}";

        # Apply mixins
        if superClasses && superClasses.length > 0 {
            result = result + self.apply_mixins(className, superClasses);
        }

        return result;
    }
    
    # Helper micro-function to apply mixins
    micro apply_mixins(self, targetClass: String, mixins: Array) -> String {
        let mixinCode = "";
        let i = 0;
        while i < mixins.length {
            let mixin = mixins[i];
            mixinCode = mixinCode + "Object.getOwnPropertyNames(" + mixin + ".prototype).forEach(name => {\n";
            mixinCode = mixinCode + "    if (name !== 'constructor') {\n";
            mixinCode = mixinCode + "        Object.defineProperty(" + targetClass + ".prototype, name, Object.getOwnPropertyDescriptor(" + mixin + ".prototype, name));\n";
            mixinCode = mixinCode + "    }\n";
            mixinCode = mixinCode + "});\n";
            i = i + 1;
        }
        return mixinCode;
    }

    # 生成 trait 声明
    micro generate_trait_declaration(self, node: Node) -> String {
        # 为 trait 生成占位符，暂时不需要完整的代码生成
        let traitName = node.name;
        return "/* Trait " + traitName + " - placeholder for future implementation */";
    }
    
    # 生成单例声明
    micro generate_singleton_declaration(self, node: Node) -> String {
        # 生成 singleton 的 JavaScript 代码
        let singletonName = node.name;
        let superClass = node.superClass;
        let members = node.members;

        let result = "const " + singletonName + " = (function() {\n";
        result = result + "  let instance = null;\n";
        result = result + "  \n";
        result = result + "  class " + singletonName + "Class";

        # 添加继承
        if superClass {
            result = result + " extends " + superClass;
        }

        result = result + " {\n";

        # 检查是否有显式构造函数
        let hasExplicitConstructor = false;
        let explicitConstructor = null;
        let fieldInits = "";
        let i = 0;
        while i < members.length {
            let member = members[i];
            if member.`type` == "ConstructorStatement" {
                hasExplicitConstructor = true;
                explicitConstructor = member;
            } else if member.`type` == "Property" {
                if member.initializer && member.initializer.`type` {
                    let initValue = self.generate_expression(member.initializer);
                    fieldInits = fieldInits + "      this." + member.name + " = " + initValue + ";\n";
                } else {
                    fieldInits = fieldInits + "      this." + member.name + " = undefined;\n";
                }
            }
            i = i + 1;
        }

        # 生成构造函数
        if hasExplicitConstructor {
            # 使用显式构造函数作为初始化逻辑
            let params = "";
            let j = 0;
            while j < explicitConstructor.parameters.length {
                if j > 0 {
                    params = params + ", ";
                }
                # 处理新的 Parameter 节点结构
                let param = explicitConstructor.parameters[j];
                if param && param.name {
                    params = params + param.name;
                } else {
                    # 兼容旧的字符串格式
                    params = params + param;
                }
                j = j + 1;
            }
            result = result + "    constructor(" + params + ") {\n";
            if superClass {
                result = result + "      super();\n";
            }
            result = result + fieldInits;
            let ctorBody = self.generate_statement(explicitConstructor.body);
            # 移格外层的大括号，只保留内容
            if ctorBody.startsWith("{\n") && ctorBody.endsWith("\n}") {
                ctorBody = ctorBody.substring(2, ctorBody.length - 2);
                # 调整缩进
                ctorBody = ctorBody.replace("\n", "\n      ");
            }
            result = result + "      " + ctorBody;
            result = result + "    }\n\n";
        } else if fieldInits != "" {
            # 自动生成构造函数用于字段初始化
            result = result + "    constructor() {\n";
            if superClass {
                result = result + "      super();\n";
            }
            result = result + fieldInits;
            result = result + "    }\n\n";
        }

        # 生成类方法
        i = 0;
        while i < members.length {
            let member = members[i];
            if member.`type` == "MemberStatement" {
                let methodName = member.name;
                let params = "";
                let j = 0;
                let paramCount = 0;
                while j < member.parameters.length {
                    # 跳过 self 参数，因为在 ES6 class 中不需要显式的 self
                    let param = member.parameters[j];
                    let paramName = "";

                    # 处理新的 Parameter 节点结构
                    if param && param.name {
                        paramName = param.name;
                    } else {
                        # 兼容旧的字符串格式
                        paramName = param;
                    }

                    if paramName != "self" {
                        if paramCount > 0 {
                            params = params + ", ";
                        }
                        params = params + paramName;
                        paramCount = paramCount + 1;
                    }
                    j = j + 1;
                }
                let body = self.generate_statement(member.body);
                # 根据是否为静态方法生成不同的代码
                # 修复：检查isInstanceMethod而不是isStatic，因为有self参数的是实例方法
                if member.isInstanceMethod {
                    result = result + "    " + methodName + "(" + params + ") " + body + "\n\n";
                } else {
                    result = result + "    static " + methodName + "(" + params + ") " + body + "\n\n";
                }
            }
            i = i + 1;
        }

        result = result + "  }\n";
        result = result + "  \n";
        result = result + "  return function() {\n";
        result = result + "    if (instance === null) {\n";
        result = result + "      instance = new " + singletonName + "Class();\n";
        result = result + "    }\n";
        result = result + "    return instance;\n";
        result = result + "  };\n";
        result = result + "})();";
        
        return result;
    }
    
    # 生成完整代码
    micro generate(self, ast: Node) -> String {
        if ast.`type` == "Program" {
            let i = 0;
            while i < ast.statements.length {
                let stmt = ast.statements[i];
                let stmt_code = self.generate_statement(stmt);
                
                # 使用带源映射的写入方法（向后兼容检查）
                let has_position = false;
                if stmt.has_valid_position {
                    has_position = stmt.has_valid_position();
                } else {
                    # 向后兼容：检查是否有基本的位置信息
                    has_position = stmt.line && stmt.column;
                }
                
                if has_position && stmt.source_file {
                    let source_span = new SourceSpan();
                    source_span.file_name = stmt.source_file;
                    source_span.start_line = stmt.source_line || stmt.line;
                    source_span.start_column = stmt.source_column || stmt.column;
                    source_span.end_line = stmt.source_line || stmt.line;
                    source_span.end_column = (stmt.source_column || stmt.column) + (stmt.source_length || stmt.length || 1);
                    self.write_line_with_mapping(stmt_code, source_span, 0);
                } else {
                    self.write_line(stmt_code);
                }
                
                i = i + 1;
            }

            return self.to_string();
        }

        if ast.`type` == "ParseError" {
            return "// Parse Error: " + ast.message + " at line " + ast.line + ", column " + ast.column;
        }

        return self.generate_statement(ast);
    }

    # Generate JavaScript code for pattern expressions
    micro generate_pattern_expression(self, pattern_node) -> String {
        if !pattern_node {
            return "Object";
        }

        if pattern_node.`type` == "TypeIdentifier" {
            # 对于TypeIdentifier，如果是未定义的标识符，返回字符串形式
            # 这样可以避免JavaScript中的"未定义"错误
            return "\"" + pattern_node.name + "\"";
        }

        if pattern_node.`type` == "Identifier" {
            # 对于普通标识符，也返回字符串形式以避免未定义错误
            return "\"" + pattern_node.name + "\"";
        }

        if pattern_node.`type` == "StringLiteral" {
            # 字符串字面量需要加引号
            return "\"" + pattern_node.value + "\"";
        }

        if pattern_node.`type` == "NumberLiteral" {
            return pattern_node.value;
        }

        if pattern_node.`type` == "BooleanLiteral" {
            return pattern_node.value;
        }

        if pattern_node.`type` == "StaticMemberAccess" {
            # 生成 eidos/flags 成员访问，如 Status.PENDING
            return pattern_node.object + "." + pattern_node.member;
        }

        # 对于未知模式，返回 Object
        return "Object";
    }

    # Generate JavaScript code for type expressions
    micro generate_type_expression(self, type_node) -> String {
        if !type_node {
            return "Object";
        }

        match type_node.`type` {
            case "TypeIdentifier":
                return type_node.name;
            case "Identifier":
                return type_node.name;
            case "ArrayType":
                return "Array";
            case "FunctionType":
                return "Function";
            # 泛型类型在 JavaScript 中无法直接表示，这里简化处理
            case "GenericType":
                return self.generate_type_expression(type_node.base);
            # 元组类型在 JavaScript 中无法直接表示，这里简化处理
            case "TupleType":
                return "Array";
            # 对象类型在 JavaScript 中无法直接表示，这里简化处理
            case "ObjectType":
                return "Object";
            # 联合类型在 JavaScript 中无法直接表示，这里简化处理
            case "UnionType":
                return "Object";
            # 交集类型在 JavaScript 中无法直接表示，这里简化处理
            case "IntersectionType":
                return "Object";
            else:
                return "Object";
        };
    }
    
    # 生成 match 表达式
    micro generate_match_expression(self, node: Node) -> String {
        let result = "";
        
        # 处理各种分支
        let i = 0;
        let is_first_when = true;
        while i < node.branches.length {
            let branch = node.branches[i];
            
            match branch.`type` {
                case "WhenBranch":
                    let condition = self.generate_expression(branch.condition);
                    if is_first_when {
                        result = result + "if (" + condition + ") {\n";
                        is_first_when = false;
                    } else {
                        result = result + " else if (" + condition + ") {\n";
                    }
                    result = result + self.generate_branch_statements(branch.statements);
                    result = result + "}";
                case "ElseBranch":
                    result = result + " else {\n";
                    result = result + self.generate_branch_statements(branch.statements);
                    result = result + "}";
                case "CaseBranch":
                    # 生成 case 分支的字面量匹配
                    let pattern_value = self.generate_pattern_expression(branch.pattern);
                    let match_value = self.generate_expression(node.expression);
                    
                    # 检查模式是否为标识符，如果是则需要特殊处理
                    if branch.pattern && branch.pattern.`type` == "Identifier" {
                        # 对于标识符模式，生成变量声明而不是比较
                        if is_first_when {
                            result = result + "if (" + match_value + " === " + branch.pattern.name + ") {\n";
                            is_first_when = false;
                        } else {
                            result = result + " else if (" + match_value + " === " + branch.pattern.name + ") {\n";
                        }
                    } else {
                        if is_first_when {
                            result = result + "if (" + match_value + " === " + pattern_value + ") {\n";
                            is_first_when = false;
                        } else {
                            result = result + " else if (" + match_value + " === " + pattern_value + ") {\n";
                        }
                    }
                    result = result + self.generate_branch_statements(branch.statements);
                    result = result + "}";
                case "TypeBranch":
                    # 暂时跳过 type 分支，第一阶段不实现
                    result = result + "// TODO: Type branch not implemented yet\n";
                else:
                    # 未知分支类型
                    result = result + "// Unknown branch type: " + branch.`type` + "\n";
            };
            
            i = i + 1;
        }
        
        return result;
    }
    
    # 生成分支语句
    micro generate_branch_statements(self, statements: Array<Node>) -> String {
        let result = "";
        let i = 0;
        while i < statements.length {
            let stmt = self.generate_statement(statements[i]);
            result = result + stmt + "\n";
            i = i + 1;
        }
        return result;
    }

    # Write line with source mapping
    micro write_line_with_mapping(self, text: String, span: SourceSpan, source_index: u32) -> unit {
        let current_indent = "";
        let i = 0;
        while i < self.indent_level {
            current_indent = current_indent + self.indent_text;
            i = i + 1;
        }

        if (self.js_mapping && span) {
            self.buffer = self.buffer + current_indent;
            self.buffer = self.buffer + self.js_mapping.generate_with_mapping(text, span, source_index);
            self.buffer = self.buffer + self.js_mapping.generate_newline();
        } else {
            self.buffer = self.buffer + current_indent + text + "\n";
        }
    }
}

# 工具方法：连接名称路径
micro join_name_path(names: Array<String>, separator: String) -> String {
    let result = "";
    let i = 0;
    while i < names.length {
        if i > 0 {
            result = result + separator;
        }
        result = result + names[i];
        i = i + 1;
    }
    return result;
}

# Add source file for source mapping
micro add_source_file(self, file_name: String, content: String) -> Number {
    if (self.source_map_builder) {
        if (!self.source_files[file_name]) {
            self.source_files[file_name] = self.source_map_builder.add_source(file_name, content);
        }
        return self.source_files[file_name];
    }
    return 0;
}