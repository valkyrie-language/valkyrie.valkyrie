namespace package::codegen;

using package::parser::Node;

# JavaScript Code Generation Write Buffer with proper indentation management
class JsCodeGeneration {
    constructor(indent_text: String) {
        self.buffer = "";
        self.indent_level = 0;
        self.indent_text = indent_text || "    ";
    }
    
    micro indent(self) {
        self.indent_level = self.indent_level + 1;
    }
    
    micro dedent(self) {
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;
        }
    }
    
    micro write(self, text: String) {
        self.buffer = self.buffer + text;
    }
    
    micro write_line(self, text: String) {
        let current_indent = "";
        let i = 0;
        while i < self.indent_level {
            current_indent = current_indent + self.indent_text;
            i = i + 1;
        }
        self.buffer = self.buffer + current_indent + text + "\n";
    }
    
    micro to_string(self) {
        return self.buffer;
    }
    
    # 工具方法：字符串替换
    micro replace_all(self, str: String, search: String, replace: String) -> String {
        let result = "";
        let i = 0;
        while i < str.length {
            if str[i] == search {
                result = result + replace;
                i = i + search.length;
            } else {
                result = result + str[i];
                i = i + 1;
            }
        }
        return result;
    }
    
    # 工具方法：连接名称路径
    micro join_name_path(self, names: Array<String>, separator: String) -> String {
        let result = "";
        let i = 0;
        while i < names.length {
            if i > 0 {
                result = result + separator;
            }
            result = result + names[i];
            i = i + 1;
        }
        return result;
    }
    
    # 生成表达式代码
    micro generate_expression(self, node: Node) -> String {
        if node.type == "Number" {
            return node.value;
        }

        if node.type == "String" {
            # 处理字符串转义，确保与bootstrap/codegen.js一致，使用模块化函数
            let escaped = node.value;
            # 替换反斜杠
            escaped = self.replace_all(escaped, "\\", "\\\\");
            # 替换双引号
            escaped = self.replace_all(escaped, "\"", "\\\"");
            # 替换换行符
            escaped = self.replace_all(escaped, "\n", "\\n");
            # 替换回车符
            escaped = self.replace_all(escaped, "\r", "\\r");
            # 替换制表符
            escaped = self.replace_all(escaped, "\t", "\\t");
            return "\"" + escaped + "\"";
        }

        if node.type == "Boolean" {
            return node.value;
        }

        if node.type == "Identifier" {
            return node.name;
        }

        if node.type == "BinaryOp" {
            let left = self.generate_expression(node.left);
            let right = self.generate_expression(node.right);
            let result = "(";
            result = result + left;
            result = result + " ";
            result = result + node.operator;
            result = result + " ";
            result = result + right;
            result = result + ")";
            return result;
        }

        if node.type == "Assignment" {
            let left = self.generate_expression(node.left);
            let right = self.generate_expression(node.right);
            return left + " = " + right;
        }

        if node.type == "MicroCall" {
            let callee = self.generate_expression(node.callee);
            let args = "";

            let i = 0;
            while i < node.arguments.length {
                if i > 0 {
                    args = args + ", ";
                }
                args = args + self.generate_expression(node.arguments[i]);
                i = i + 1;
            }

            # 检查是否有尾随闭包
            if node.closure {
                # 生成尾随闭包的 JavaScript 代码
                let closureParams = "";
                # 尾随闭包通常没有参数，或者参数在调用时推断

                let closureBody = "";
                if node.closure {
                    # closure 是一个 Block 节点
                    closureBody = self.generate_statement(node.closure);
                }

                # 如果有普通参数，添加逗号分隔
                if args.length > 0 {
                    args = args + ", ";
                }
                args = args + "micro(" + closureParams + ") " + closureBody;
            }

            return callee + "(" + args + ")";
        }

        if node.type == "AnonymousFunction" {
            let params = "";
            let i = 0;
            while i < node.parameters.length {
                if i > 0 {
                    params = params + ", ";
                }
                let param = node.parameters[i];
                if param && param.name {
                    params = params + param.name;
                } else {
                    params = params + param;
                }
                i = i + 1;
            }

            let body = "";
            if node.body {
                body = self.generate_statement(node.body);
            }

            return "micro(" + params + ") " + body;
        }

        if node.type == "NewExpression" {
            let args = "";

            let i = 0;
            while i < node.arguments.length {
                if i > 0 {
                    args = args + ", ";
                }
                args = args + self.generate_expression(node.arguments[i]);
                i = i + 1;
            }

            # 检查是否有解析后的类名
            let className = node.className;
            if node.resolvedClassName {
                className = node.resolvedClassName;
            }

            return "new " + className + "(" + args + ")";
        }

        if node.type == "AwaitExpression" {
            let argument = self.generate_expression(node.argument);
            return "await " + argument;
        }

        if node.type == "PropertyAccess" {
            if node.object.type {
                let obj = self.generate_expression(node.object);
                return obj + "." + node.property;
            } else {
                return node.object + "." + node.property;
            }
        }

        if node.type == "StaticMethodCall" {
            let className = "";
            if node.namespacePath {
                # 使用新的namespacePath支持多级命名空间
                if node.namespacePath.length >= 2 {
                    className = node.namespacePath[node.namespacePath.length - 2];
                } else {
                    className = node.namespacePath[0];
                }
            } else if node.className.type {
                className = self.generate_expression(node.className);
            } else {
                className = node.className;
            }

            let args = "";
            let i = 0;
            while i < node.arguments.length {
                if i > 0 {
                    args = args + ", ";
                }
                args = args + self.generate_expression(node.arguments[i]);
                i = i + 1;
            }

            return className + "." + node.methodName + "(" + args + ")";
        }

        if node.type == "StaticPropertyAccess" {
            let className = "";
            if node.namespacePath {
                # 使用新的namespacePath支持多级命名空间
                if node.namespacePath.length >= 2 {
                    className = node.namespacePath[node.namespacePath.length - 2];
                } else {
                    className = node.namespacePath[0];
                }
            } else if node.className.type {
                className = self.generate_expression(node.className);
            } else {
                className = node.className;
            }

            return className + "." + node.property;
        }

        if node.type == "ArrayAccess" {
            let obj = "";
            if node.object.type {
                obj = self.generate_expression(node.object);
            } else {
                obj = node.object;
            }
            let index = self.generate_expression(node.index);
            return obj + "[" + index + "]";
        }

        if node.type == "ObjectLiteral" {
            if node.properties.length == 0 {
                return "{}";
            }
            let result = "{";
            let i = 0;
            while i < node.properties.length {
                let prop = node.properties[i];
                if i > 0 {
                    result = result + ", ";
                }
                result = result + "\"" + prop.key + "\": " + self.generate_expression(prop.value);
                i = i + 1;
            }
            result = result + "}";
            return result;
        }

        if node.type == "ArrayLiteral" {
            return "[]";
        }

        if node.type == "UnaryOp" {
            let operand = self.generate_expression(node.operand);
            return node.operator + operand;
        }

        if node.type == "ThisExpression" {
            return "this";
        }

        if node.type == "DefaultValue" {
            return "undefined";
        }

        return "/* Unknown expression: " + node.type + " */";
    }
    
    # 生成语句代码
    micro generate_statement(self, node: Node) -> String {
        if node.type == "LetStatement" {
            let value = self.generate_expression(node.value);
            return "let " + node.name + " = " + value + ";";
        }

        if node.type == "NamespaceStatement" {
            # namespace 语句在单文件编译中被忽略，在多文件编译中用于符号管理
            let namespacePath = self.join_name_path(node.path, "::");
            if node.isMainNamespace {
                return "// namespace! " + namespacePath + ";";
            } else {
                return "// namespace " + namespacePath + ";";
            }
        }

        if node.type == "UsingStatement" {
            # using 语句在整合编译中被忽略，在多文件编译中用于符号导入
            return "// using " + self.join_name_path(node.path, "::") + ";";
        }

        if node.type == "JSAttributeStatement" {
            # 生成 JS 导入语句：import {importName as functionName} from "modulePath"
            return "import { " + node.importName + " as " + node.functionName + " } from \"" + node.modulePath + "\";";
        }

        if node.type == "ImportJsStatement" {
            # 生成 JS 导入语句：import {importName as localName} from "module"
            return "import { " + node.importName + " as " + node.localName + " } from \"" + node.module + "\";";
        }

        if node.type == "MicroDeclaration" {
            let params = "";
            let i = 0;
            while i < node.parameters.length {
                if i > 0 {
                    params = params + ", ";
                }
                # 处理新的 Parameter 节点结构
                let param = node.parameters[i];
                if param && param.name {
                    params = params + param.name;
                } else {
                    # 兼容旧的字符串格式
                    params = params + param;
                }
                i = i + 1;
            }

            let body = self.generate_statement(node.body);
            # 直接使用 name 字段（已经是解析后的名称）
            let functionName = node.name;
            return "export function " + functionName + "(" + params + ") " + body;
        }

        if node.type == "MemberStatement" {
            let params = "";
            let i = 0;
            while i < node.parameters.length {
                if i > 0 {
                    params = params + ", ";
                }
                # 处理新的 Parameter 节点结构
                let param = node.parameters[i];
                if param && param.name {
                    params = params + param.name;
                } else {
                    # 兼容旧的字符串格式
                    params = params + param;
                }
                i = i + 1;
            }

            let body = self.generate_statement(node.body);
            return "function " + node.name + "(" + params + ") " + body;
        }

        if node.type == "IfStatement" {
            let condition = self.generate_expression(node.condition);
            let thenBranch = self.generate_statement(node.thenBranch);
            let result = "if (" + condition + ") " + thenBranch;

            if node.elseBranch && node.elseBranch.type {
                let elseBranch = self.generate_statement(node.elseBranch);
                result = result + " else " + elseBranch;
            }

            return result;
        }

        if node.type == "WhileStatement" {
            let condition = self.generate_expression(node.condition);
            let body = self.generate_statement(node.body);
            return "while (" + condition + ") " + body;
        }

        if node.type == "UntilStatement" {
            let condition = self.generate_expression(node.condition);
            let body = self.generate_statement(node.body);
            return "while (!(" + condition + ")) " + body;
        }

        if node.type == "ReturnStatement" {
            if node.value && node.value.type {
                let value = self.generate_expression(node.value);
                return "return " + value + ";";
            } else {
                return "return;";
            }
        }

        if node.type == "Block" {
            let statements = "";
            let i = 0;
            while i < node.statements.length {
                let stmt = self.generate_statement(node.statements[i]);
                if i > 0 {
                    statements = statements + "\n";
                }
                statements = statements + stmt;
                i = i + 1;
            }
            return "{\n" + statements + "\n}";
        }

        if node.type == "ExpressionStatement" {
            return self.generate_expression(node.expression) + ";";
        }

        if node.type == "NamespaceStatement" {
            # namespace 语句在单文件编译中被忽略，在多文件编译中用于符号管理
            return "// namespace " + self.join_name_path(node.path, "::") + ";";
        }

        if node.type == "UsingStatement" {
            # using 语句在单文件编译中被忽略，在多文件编译中用于符号导入
            return "// using " + self.join_name_path(node.path, "::") + ";";
        }

        if node.type == "JSAttributeStatement" {
            # 生成 JS 导入语句和函数定义
            let cleanImportName = self.replace_all(node.importName, "-", "_");
            cleanImportName = self.replace_all(cleanImportName, ".", "_");
            cleanImportName = self.replace_all(cleanImportName, "/", "_");
            let uniqueName = node.functionName + "_" + cleanImportName;
            let importStatement = "import { " + node.importName + " as " + uniqueName + " } from \"" + node.modulePath + "\";";

            # 生成函数包装
            let params = "";
            let i = 0;
            while i < node.parameters.length {
                if i > 0 {
                    params = params + ", ";
                }
                params = params + node.parameters[i];
                i = i + 1;
            }

            let functionDef = "export function " + node.functionName + "(" + params + ") {\n";
            functionDef = functionDef + "  return " + uniqueName + "(" + params + ");\n";
            functionDef = functionDef + "}";

            return importStatement + "\n" + functionDef;
        }

        if node.type == "ClassDeclaration" {
            # 直接使用 name 字段（已经是解析后的名称）
            let className = node.name;
            let superClass = node.superClass;
            let members = node.members;

            let result = "class " + className;

            # 添加继承
            if superClass {
                result = result + " extends " + superClass;
            }

            result = result + " {\n";

            # 检查是否有显式构造函数
            let hasExplicitConstructor = false;
            let explicitConstructor = null;
            let fieldInits = "";
            let i = 0;
            while i < members.length {
                let member = members[i];
                if member.type == "ConstructorStatement" {
                    hasExplicitConstructor = true;
                    explicitConstructor = member;
                } else if member.type == "Property" {
                    if member.initializer && member.initializer.type {
                        let initValue = self.generate_expression(member.initializer);
                        fieldInits = fieldInits + "    self." + member.name + " = " + initValue + ";\n";
                    } else {
                        fieldInits = fieldInits + "    self." + member.name + " = undefined;\n";
                    }
                }
                i = i + 1;
            }

            # 生成构造函数
            if hasExplicitConstructor {
                # 使用显式构造函数
                let params = "";
                let j = 0;
                while j < explicitConstructor.parameters.length {
                    if j > 0 {
                        params = params + ", ";
                    }
                    # 处理新的 Parameter 节点结构
                    let param = explicitConstructor.parameters[j];
                    if param && param.name {
                        params = params + param.name;
                    } else {
                        # 兼容旧的字符串格式
                        params = params + param;
                    }
                    j = j + 1;
                }
                result = result + "  constructor(" + params + ") {\n";
                if superClass {
                    result = result + "    super();\n";
                }
                result = result + fieldInits;
                let ctorBody = self.generate_statement(explicitConstructor.body);
                # 移格外层的大括号，只保留内容
                if ctorBody.startsWith("{\n") && ctorBody.endsWith("\n}") {
                    ctorBody = ctorBody.substring(2, ctorBody.length - 2);
                }
                result = result + ctorBody;
                result = result + "  }\n\n";
            } else if fieldInits != "" {
                # 自动生成构造函数用于字段初始化
                result = result + "  constructor() {\n";
                if superClass {
                    result = result + "    super();\n";
                }
                result = result + fieldInits;
                result = result + "  }\n\n";
            }

            # 生成类方法
            i = 0;
            while i < members.length {
                let member = members[i];
                if member.type == "MemberStatement" {
                    let methodName = member.name;
                    let params = "";
                    let j = 0;
                    let paramCount = 0;
                    while j < member.parameters.length {
                        # 跳过 self 参数，因为在 ES6 class 中不需要显式的 self
                        let param = member.parameters[j];
                        let paramName = "";

                        # 处理新的 Parameter 节点结构
                        if param && param.name {
                            paramName = param.name;
                        } else {
                            # 兼容旧的字符串格式
                            paramName = param;
                        }

                        if paramName != "self" {
                            if paramCount > 0 {
                                params = params + ", ";
                            }
                            params = params + paramName;
                            paramCount = paramCount + 1;
                        }
                        j = j + 1;
                    }
                    let body = self.generate_statement(member.body);
                    # 根据是否为静态方法生成不同的代码
                    if member.isStatic {
                        result = result + "  static " + methodName + "(" + params + ") " + body + "\n\n";
                    } else {
                        result = result + "  " + methodName + "(" + params + ") " + body + "\n\n";
                    }
                }
                i = i + 1;
            }

            result = result + "}";
            return result;
        }

        # 表达式语句 - 移除这个处理，让所有表达式都通过ExpressionStatement处理
        return "/* Unknown statement: " + node.type + " */";
    }
    
    # 生成完整代码
    micro generate(self, ast: Node) -> String {
        if ast.type == "Program" {
            let i = 0;
            while i < ast.statements.length {
                let stmt = ast.statements[i];
                let stmt_code = self.generate_statement(stmt);
                self.write_line(stmt_code);
                i = i + 1;
            }

            return self.to_string();
        }

        if ast.type == "ParseError" {
            return "// Parse Error: " + ast.message + " at line " + ast.line + ", column " + ast.column;
        }

        return self.generate_statement(ast);
    }
}