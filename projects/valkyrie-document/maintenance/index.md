# Valkyrie 虚拟机维护指南

本指南面向 Valkyrie 虚拟机项目的**内部维护者和核心开发团队**，介绍项目架构、模块职责、内部维护流程和系统级设计决策。

> **目标读者**: 项目维护者、核心开发团队成员、系统架构师
> **内容重点**: 内部架构、维护流程、系统设计、代码组织

## 项目架构概览

Nyar 采用 Rust Monorepo (Workspace) 架构，每个组件封装在独立的 crate 中，提供清晰的依赖关系、独立的测试环境和高效的并行编译。

```
nyar/
├── Cargo.toml         # Workspace 根配置，定义所有成员
└── projects/
    ├── nyar-ast/      # 抽象语法树 (AST) 定义
    ├── nyar-hir/      # 高层语义 IR (HIR) 和语义分析
    ├── nyar-mir/      # 中层控制流 IR (MIR) 和 CFG 生成
    ├── nyar-lir/      # 低层线性 IR (LIR) 和降级逻辑
    ├── nyar-wasm/     # WebAssembly 代码生成
    ├── valkyrie-parser/ # 源文本解析器
    ├── nyar-query/    # Salsa 查询和增量计算
    ├── nyar-core/     # 基础类型和符号定义
    ├── nyar-error/    # 统一错误和诊断系统
    ├── nyar-interpreter/ # MIR 执行引擎
    └── nyar-cli/      # 命令行工具
```

## 核心设计哲学

Nyar 的架构基于五大设计支柱：

### 1. 以中间表示为中心的骨架 (IR-Centric Skeleton)

编译器是对程序信息进行一系列保义变换的过程，建模为多个精心设计的中间表示串联的流水线：

- **AST**: 忠实于源代码的语法结构，不包含语义信息
- **HIR**: 整个程序的全局语义图，包含完整的类型、作用域、模块间依赖关系
- **MIR**: 以控制流图形式表示程序执行逻辑，为代数效应、异步等非线性控制流建模
- **LIR**: 接近目标机器的线性指令集，可轻松映射到目标平台原语

### 2. 开发者体验的终极追求 (Uncompromising Developer Experience)

- **诊断即对话**: 使用 `miette` 框架提供 IDE 级别的诊断体验
- **心流不被打断**: 通过 `Salsa` 增量计算实现亚秒级响应
- **直觉且强大的语言**: 提供代数效应、强大的模式匹配等高级抽象

### 3. 抽象的统一与对称 (Unity and Duality of Abstractions)

基于数据与控制的对偶性：
- `match` 表达式：对数据的分解和模式匹配
- `handle` 表达式：对控制流（代数效应）的分解和模式匹配

### 4. 执行模型的二元性 (Duality of Execution Models)

- **动态解释执行**: 专为开发、调试和交互式环境设计，内建完整运行时
- **静态编译执行**: 专为生产部署设计，编译为轻量、高效的 WebAssembly 模块

### 5. 零成本抽象的最终承诺 (Zero-Cost Abstraction)

高级抽象在编译后应与手写的最优底层代码同样高效。

## 核心模块详解

### nyar-ast: 强类型抽象语法树

**职责**: 定义语言的抽象语法树，提供对源代码语法的直接、无损表示。

**设计原则**:
- **忠实性**: 精确反映用户编写的代码，包括所有语法结构
- **强类型化**: 避免通用 Node 包装器，直接使用具体的 enum 变体
- **位置追踪**: 每个节点携带 `SourceSpan` 用于精确诊断

**关键组件**:
- `Module` - 源文件或代码块的顶层结构
- `Item` - 顶层项（函数、结构体、枚举等）
- `Expression` - 表达式系统
- `Pattern` - 模式匹配
- `TypeExpr` - 类型表达式

### nyar-hir: 全局语义图

**职责**: 构建整个程序的静态语义表示，进行名称解析、类型检查和语义分析。

**设计原则**:
- **全局性**: 代表整个项目的所有代码，不仅仅是单个文件
- **语义明确**: 消除 AST 中的所有模糊性
- **类型完备**: 每个表达式都有明确的类型信息

**关键组件**:
- 名称解析器 - 将字符串标识符解析为唯一 ID
- 类型检查器 - 验证类型一致性和安全性
- 模块链接器 - 处理跨模块依赖关系

### nyar-mir: 控制流图表示

**职责**: 将 HIR 转换为控制流图形式，为优化和代数效应处理做准备。

**设计原则**:
- **显式控制流**: 所有控制流转移都明确表示
- **SSA 形式**: 静态单赋值形式便于分析和优化
- **效应建模**: 为代数效应和异步操作提供一等支持

**关键组件**:
- 基本块构建器
- SSA 转换器
- 效应处理器

### nyar-lir: 低层线性表示

**职责**: 提供接近目标机器的线性指令表示，为多后端代码生成做准备。

**设计原则**:
- **目标无关**: 不绑定特定的目标平台
- **线性化**: 消除复杂的控制流结构
- **优化友好**: 便于进行低层优化

**关键组件**:
- 指令集定义
- 寄存器分配
- 优化 passes

### nyar-wasm: WebAssembly 代码生成

**职责**: 将 LIR 翻译为 WebAssembly 二进制模块。

**设计原则**:
- **WasmGC 优先**: 利用 WebAssembly GC 提案的原生能力
- **轻量输出**: 生成体积小、启动快的模块
- **互操作性**: 与现有 Wasm 生态系统无缝集成

### valkyrie-parser: 源文本解析

**职责**: 将源文本字符串解析为 AST。

**注意**: 严格来说，这个语言解析器不是 nyar-vm 的一部分，而是独立的前端工具。

### nyar-interpreter: 动态执行引擎

**职责**: 提供完整的 MIR 执行环境，包含内建运行时。

**设计原则**:
- **完整性**: 内聚的 GC、运行时和 Wasm FFI
- **调试友好**: 提供丰富的调试和分析能力
- **交互性**: 支持 REPL 和动态代码执行

### nyar-query: 增量计算核心

**职责**: 基于 Salsa 框架管理依赖关系、缓存和增量计算。

**设计原则**:
- **细粒度**: 将编译过程分解为可缓存的小任务
- **依赖追踪**: 自动管理计算之间的依赖关系
- **缓存优化**: 最小化重复计算

## 维护流程

### 代码审查标准

1. **架构一致性**: 确保新代码符合五大设计支柱
2. **错误处理**: 使用统一的 `nyar-error` 系统
3. **测试覆盖**: 每个 crate 都应有充分的单元测试
4. **文档完整**: 公共 API 必须有文档注释
5. **性能考虑**: 避免不必要的分配和拷贝

### 发布流程

1. **版本同步**: 所有 crate 使用统一的版本号
2. **兼容性检查**: 确保 API 变更的向后兼容性
3. **性能回归测试**: 运行基准测试确保性能不退化
4. **文档更新**: 同步更新用户文档和示例

### 调试指南

1. **编译器错误**: 检查 `nyar-error` 的诊断输出
2. **性能问题**: 使用 Salsa 的查询分析工具
3. **内存问题**: 在解释器模式下使用内建的 GC 分析
4. **代码生成问题**: 检查各个 IR 层的输出

## 扩展指南

### 添加新的语言特性

1. 在 `nyar-ast` 中添加语法表示
2. 在 `valkyrie-parser` 中添加解析逻辑
3. 在 `nyar-hir` 中添加语义分析
4. 在 `nyar-mir` 中添加控制流处理
5. 在 `nyar-lir` 中添加降级逻辑
6. 在后端中添加代码生成支持

### 添加新的后端

1. 创建新的 `nyar-{target}` crate
2. 实现 LIR 到目标代码的翻译
3. 添加目标特定的优化
4. 集成到 `nyar-cli` 中

## 后端实现

### [Rust后端](rust-backend.md)
Nyar语言的Rust后端实现，包括编译器核心、类型系统、代码生成等。

### [JavaScript后端](javascript-backend.md)
JavaScript后端实现，将LIR编译为高效的JavaScript代码，支持快速原型开发和Web集成。

### [Rust服务器](rust-server.md)
基于Rust的Nyar编译器基础设施，为宿主语言提供统一的LSP查询体系、代码分析、智能提示等功能。

### 性能优化

1. **编译时优化**: 在 Salsa 查询中添加缓存
2. **运行时优化**: 在解释器中优化热路径
3. **代码生成优化**: 在 LIR 层添加优化 passes
4. **内存优化**: 减少不必要的分配和拷贝

## 故障排除

### 常见问题

1. **编译缓慢**: 检查 Salsa 查询的粒度和缓存策略
2. **内存使用过高**: 分析 HIR 图的大小和解释器的 GC 行为
3. **生成代码性能差**: 检查 LIR 优化 passes 和后端翻译
4. **诊断信息不准确**: 验证 AST 节点的 SourceSpan 信息

### 调试工具

1. **IR 转储**: 使用 `--dump-{ast,hir,mir,lir}` 选项
2. **查询分析**: 使用 Salsa 的内建分析工具
3. **性能分析**: 使用 `perf` 或 `flamegraph` 工具
4. **内存分析**: 使用解释器的内建 GC 统计

---

本维护指南将随着项目的发展持续更新。如有疑问，请参考各个 crate 的具体文档或提交 Issue。